/* host.three.js build output file copied from the Amazon Sumerian Three.js example (MIT) */
alert('it works!')
!function (e, t) {
	"object" == typeof exports && "object" == typeof module
		? module.exports = t()
		: "function" == typeof define && define.amd
			? define("HOST", [], t)
			: "object" == typeof exports
				? (alert('WTH'), exports.HOST = t())
				: e.HOST = t()
}("undefined" != typeof self ? self : "undefined" != typeof global ? global : this, (() => (() => { "use strict"; var e = { 937: (e, t, i) => { i.d(t, { AnimationFeature: () => we, AnimationLayer: () => Le, AnimationTypes: () => Te, AnimationUtils: () => $e, AxisMap: () => q, Blend1dState: () => Ie, Blend2dState: () => Pe, DefaultGestureWords: () => F, DefaultLayerBlendMode: () => Ne, DefaultVisemeMap: () => L, Deferred: () => s, Easing: () => be, FreeBlendState: () => Oe, GestureFeature: () => M, HostObject: () => l, LayerBlendModes: () => xe, LexFeature: () => Ve, LexUtils: () => Re, LipsyncFeature: () => x, MathUtils: () => o, Messenger: () => h, PointOfInterestFeature: () => ie, QueueState: () => Ce, RandomAnimationState: () => ke, SingleState: () => Fe, Speech: () => Ue, TextToSpeechFeature: () => je, TextToSpeechUtils: () => De, TransitionState: () => Me, Utils: () => n }); class Deferred extends Promise{ constructor(e = (() => { }), t, i, s) { if ("function" != typeof e) throw new Error("Cannot create new Deferred. Executable must be a function."); if (void 0 !== t && "function" != typeof t) throw new Error("Cannot create new Deferred. OnResolve must be a function."); if (void 0 !== i && "function" != typeof i) throw new Error("Cannot create new Deferred. OnReject must be a function."); if (void 0 !== s && "function" != typeof s) throw new Error("Cannot create new Deferred. OnCancel must be a function."); let n, a, r; const o = { resolved: !1, rejected: !1, canceled: !1, pending: !0 }; super(((h, c) => { n = e => { if (o.pending) return o.resolved = !0, o.pending = !1, "function" == typeof t && (e = t(e)), h(e) }, a = e => { if (o.pending) return o.rejected = !0, o.pending = !1, "function" == typeof i && (e = i(e)), c(e) }, r = e => { if (o.pending) return o.canceled = !0, o.pending = !1, "function" == typeof s && (e = s(e)), h(e) }, e(n, a, r) })), this._status = o, this._resolve = n, this._reject = a, this._cancel = r, this._executable = e } get resolved() { return this._status.resolved } get rejected() { return this._status.rejected } get canceled() { return this._status.canceled } get pending() { return this._status.pending } resolve(e) { return this._resolve(e) } reject(e) { return this._reject(e) } cancel(e) { return this._cancel(e) } execute(...e) { this.pending && this._executable(this._resolve, this._reject, this._cancel, ...e) } static cancel(e) { return new Deferred(((t, i, s) => { s(e) })) } static all(e, t, i, s) { if (null == e || "function" != typeof e[Symbol.iterator]) { let e = "Cannot execute Deferred.all. First argument must be iterable."; return "function" == typeof i && (e = i(e)), Deferred.reject(e) } const n = [...e], a = n.filter((e => e instanceof Deferred)), r = new Deferred(void 0, (e => (a.forEach((t => { t.resolve(e) })), a.length = 0, "function" == typeof t ? t(e) : e)), (e => (a.forEach((t => { t.reject(e) })), a.length = 0, "function" == typeof i ? i(e) : e)), (e => (a.forEach((t => { t.cancel(e) })), a.length = 0, "function" == typeof s ? s(e) : e))), o = n.length, h = { failed: !1, numResolved: 0, resolutions: [] }; return n.forEach(((e, t) => { if (!h.failed) return e instanceof Promise ? void e.then((i => { h.failed || e.canceled ? h.failed || (h.failed = !0, r.cancel(i)) : (h.resolutions[t] = i, h.numResolved += 1, h.numResolved === o && r.resolve(h.resolutions)) }), (e => { h.failed || (h.failed = !0, r.reject(e)) })) : (h.resolutions[t] = e, h.numResolved += 1, void (h.numResolved === o && r.resolve(h.resolutions))) })), r } } const s = Deferred; class Utils{ static createId() { return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, (e => { const t = Math.floor((Date.now() + 16 * Math.random()) % 16); return "x" === e ? t.toString(16) : (3 & t | 8).toString(16) })) } static getUniqueName(e, t = []) { if (!t.includes(e)) return e; const i = new Set(t), s = e.match(/\d*$/), { index: n } = s, a = e.slice(0, n); let r = Number(s[0]); return i.forEach((e => { const t = e.match(/\d*$/); if (e.slice(0, t.index) === a) { const e = Number(t[0]); e > r && (r = e) } })), `${a}${r + 1}` } static wait(e = 0, { onFinish: t, onProgress: i, onCancel: n, onError: a } = {}) { if ("number" != typeof e && (console.warn(`Invalid seconds value ${e} for wait. Defaulting to 0.`), e = 0), e <= 0) return "function" == typeof t && t(), s.resolve(); let r = 0; const o = 1e3 * e; return new s(((e, t, s, n = 0) => { if ("number" == typeof n) 0 !== n && (r += n, r < 0 && (r = 0), "function" == typeof i && i(Math.min(r / o, 1)), r >= o && e()); else { t(new Error("Invalid property wait deltaTime. DeltaTime must be a number.")) } }), t, a, n) } static getRandomFloat(e, t) { return Math.random() * (t - e) + e } static getRandomInt(e, t) { return e = Math.ceil(e), t = Math.floor(t), Math.floor(Math.random() * (t - e)) + e } static addStringOnlyOnce(e, t) { return null == e ? t : -1 !== e.indexOf(t) ? e : e.concat(" ", t) } static addCoreUserAgentComponent(e) { const t = `SumerianHosts-${Utils.getVersion()}`; return Utils.addStringOnlyOnce(e, t) } static getVersion() { return "development" } } const n = Utils, a = 180 / Math.PI, r = Math.PI / 180; class MathUtils{ static toDegrees(e) { return e * a } static toRadians(e) { return e * r } static lerp(e, t, i) { return e + (t - e) * i } static clamp(e, t = 0, i = 1) { return Math.max(t, Math.min(e, i)) } static closestPointOnLine(e, t, i) { const s = MathUtils.distanceSquared(e, t); if (0 === s) return e; const n = ((i[0] - e[0]) * (t[0] - e[0]) + (i[1] - e[1]) * (t[1] - e[1])) / s; let a = [...e]; return n > 1 ? a = [...t] : n > 0 && (a = [e[0] + n * (t[0] - e[0]), e[1] + n * (t[1] - e[1])]), a } static distanceSquared(e, t) { return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]) } static getDelaunayTriangulation(e) { if (!e || e.length < 3) throw new Error(`Cannot get delaunay triangulation for points ${e}. Input must contain at least three points.`); let t = Number.POSITIVE_INFINITY, i = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, n = Number.NEGATIVE_INFINITY; e.forEach((e => { t = e[0] < t ? e[0] : t, i = e[1] < i ? e[1] : i, s = e[0] > s ? e[0] : s, n = e[1] > n ? e[1] : n })); const a = s - t, r = n - i, o = (t + s) / 2, h = (i + n) / 2, c = a > r ? a : r, l = [e.length, e.length + 1, e.length + 2], u = [...e, [o - 20 * c, h - c], [o, h + 20 * c], [o + 20 * c, h - c]], d = MathUtils.sortPointsCCW(l, u), m = [{ indices: d, edges: [[d[0], d[1]], [d[1], d[2]], [d[2], d[0]]] }]; u.forEach(((e, t) => { const i = []; m.forEach((t => { MathUtils.isPointInCircumCircle(u[t.indices[0]], u[t.indices[1]], u[t.indices[2]], e) && i.push(t) })); const s = []; i.forEach((e => { e.edges.forEach((t => { let n = 0; i.forEach((i => { e !== i && i.edges.forEach((e => { (t[0] === e[0] && t[1] === e[1] || t[1] === e[0] && t[0] === e[1]) && (n += 1) })) })), 0 === n && s.push(t) })) })), i.forEach((e => { m.splice(m.indexOf(e), 1) })), s.forEach((e => { const i = MathUtils.sortPointsCCW([e[0], e[1], t], u); m.push({ indices: i, edges: [[i[0], i[1]], [i[1], i[2]], [i[2], i[0]]] }) })) })); const _ = []; return m.forEach((e => { e.indices.forEach((t => { l.includes(t) && _.push(e) })) })), _.forEach((e => { const t = m.indexOf(e); -1 !== t && m.splice(t, 1) })), m.map((e => e.indices)) } static isPointInCircumCircle(e, t, i, s) { const n = e[0] - s[0], a = e[1] - s[1], r = t[0] - s[0], o = t[1] - s[1], h = i[0] - s[0], c = i[1] - s[1]; return (n * n + a * a) * (r * c - h * o) - (r * r + o * o) * (n * c - h * a) + (h * h + c * c) * (n * o - r * a) > 0 } static isPointInTriangle(e, t, i, s) { const n = (t[1] - i[1]) * (e[0] - i[0]) + (i[0] - t[0]) * (e[1] - i[1]), a = ((t[1] - i[1]) * (s[0] - i[0]) + (i[0] - t[0]) * (s[1] - i[1])) / n, r = ((i[1] - e[1]) * (s[0] - i[0]) + (e[0] - i[0]) * (s[1] - i[1])) / n, o = 1 - a - r; return a >= 0 && a <= 1 && r >= 0 && r <= 1 && o >= 0 && o <= 1 } static sortPointsCCW(e, t) { const i = [0, 0]; return e.forEach((e => { i[0] += t[e][0], i[1] += t[e][1] })), i[0] /= e.length, i[1] /= e.length, e.sort(((e, s) => { const n = Math.atan2(t[s][1] - i[1], t[s][0] - i[0]); return Math.atan2(t[e][1] - i[1], t[e][0] - i[0]) - n })), e } static triangleArea(e, t, i) { return Math.abs(.5 * (e[0] * (t[1] - i[1]) + t[0] * (i[1] - e[1]) + i[0] * (e[1] - t[1]))) } static getVectorMagnitude(e) { if (!(e instanceof Array)) throw new Error(`Cannot get magnitude for vector ${e}. Input must be an Array numbers.`); return Math.sqrt(e.reduce(((t, i) => { if ("number" != typeof i) throw new Error(`Cannot get magnitude for vector ${e}. All items in the input Array must be numbers.`); return t + i ** 2 }), 0)) } static getDotProduct(e, t) { if (!(e instanceof Array && t instanceof Array && e.length === t.length)) throw new Error(`Cannot get dot product between ${e} and ${t}. Inputs must be vectors of the same length.`); let i = 0; return e.forEach(((s, n) => { const a = t[n]; if ("number" != typeof s || "number" != typeof a) throw new Error(`Cannot get dot product between ${e} and ${t}. Vectors must only consist of numeric values.`); i += s * a })), i } static getAngleBetween(e, t) { const i = this.normalizeVector([...e]), s = this.normalizeVector([...t]), n = this.getDotProduct(i, s); return Math.acos(this.clamp(n, -1, 1)) } static rotateVector(e, t) { if (!(e instanceof Array && 3 === e.length && e.every((e => "number" == typeof e)))) throw new Error(`Cannot rotate vector ${e} by rotation matrix ${t}. Input vector must be an array of 3 numbers.`); if (!(t instanceof Array && 9 === t.length && t.every((e => "number" == typeof e)))) throw new Error(`Cannot rotate vector ${e} by rotation matrix ${t}. Input matrix3 must be an array of 9 numbers.`); return [t[0] * e[0] + t[3] * e[1] + t[6] * e[2], t[1] * e[0] + t[4] * e[1] + t[7] * e[2], t[2] * e[0] + t[5] * e[1] + t[8] * e[2]] } static normalizeVector(e) { const t = this.getVectorMagnitude(e); return 0 === t ? e.fill(0) : e.forEach(((i, s) => { e[s] = i / t })), e } static getRotationMatrix(e) { if (!(e instanceof Array && 16 === e.length && e.every((e => "number" == typeof e)))) throw new Error(`Cannot convert matrix ${e} to a rotation matrix. Input matrix must be an array of 16 numbers.`); const t = 1 / (this.getVectorMagnitude(e.slice(0, 4)) || 1), i = 1 / (this.getVectorMagnitude(e.slice(4, 8)) || 1), s = 1 / (this.getVectorMagnitude(e.slice(8, 12)) || 1); return [e[0] * t, e[1] * t, e[2] * t, e[4] * i, e[5] * i, e[6] * i, e[8] * s, e[9] * s, e[10] * s] } static cartesianToSpherical(e, t, i) { const s = this.getVectorMagnitude([e, t, i]); return 0 === s ? [0, 0, 0] : [s, Math.acos(this.clamp(t / s, -1, 1)), Math.atan2(e, i)] } static dampValue(e, t, i = [0, 0], s = 1e-7, n = .3, a = 1e7) { n = Math.max(1e-4, n), s = Math.max(1e-7, s); const r = a * n, o = e - t, h = this.clamp(o, -r, r), c = e - h, l = 2 / n, u = l * s, d = 1 / (1 + u + .5 * u ** 2 + .25 * u ** 3), m = (i[1] + l * h) * s; return i[0] = c + (h + m) * d, i[1] = (i[1] - l * m) * d, t - e > 0 == i[0] > t && (i[0] = t, i[1] = (i[0] - t) / s), i } } const o = MathUtils; class Messenger{ constructor(e) { this._id = void 0 !== e ? e : n.createId(), this._dispatcher = window, this._callbacks = {}, this._eventListeners = {} } get id() { return this._id } _createLocalMessage(e) { return `${this.id}.${e}` } _createListener(e) { return t => { let i; null !== t.detail && (i = t.detail), e(i) } } _createEvent(e, t) { return new CustomEvent(e, { detail: t }) } _addListener(e, t) { this._dispatcher.addEventListener(this._createLocalMessage(e), t) } _removeListener(e, t) { this._dispatcher.removeEventListener(this._createLocalMessage(e), t) } listenTo(e, t) { if ("function" != typeof t) throw new Error(`Cannot add listener for ${e} on ${this.id}. Callback must be a function.`); void 0 === this._callbacks[e] && (this._callbacks[e] = [], this._eventListeners[e] = []); const i = this._createListener(t); this._callbacks[e].push(t), this._eventListeners[e].push(i), this._addListener(e, i) } stopListening(e, t) { if (void 0 === this._callbacks[e]) return; if (void 0 === t) { for (let t = this._callbacks[e].length - 1; t > -1; t--)this.stopListening(e, this._callbacks[e][t]); return } const i = this._callbacks[e].indexOf(t); if (-1 === i) return; const s = this._eventListeners[e][i]; this._removeListener(e, s), this._callbacks[e].splice(i, 1), this._eventListeners[e].splice(i, 1), 0 === this._callbacks[e].length && (delete this._callbacks[e], delete this._eventListeners[e]) } stopListeningByRegexp(e, t) { Object.keys(this._callbacks).filter((t => e.test(t))).forEach((e => { this.stopListening(e, t) })) } stopListeningToAll() { const e = Object.keys(this._callbacks); for (let t = e.length - 1; t > -1; t--)this.stopListening(e[t]) } emit(e, t) { if (void 0 === this._callbacks[e]) return; e = this._createLocalMessage(e); const i = this._createEvent(e, t); this._dispatcher.dispatchEvent(i) } static listenTo(e, t, i) { this.GlobalMessenger.listenTo(e, t, i) } static stopListening(e, t) { this.GlobalMessenger.stopListening(e, t) } static stopListeningByRegexp(e, t) { Object.keys(this.GlobalMessenger._callbacks).filter((t => e.test(t))).forEach((e => { this.stopListening(e, t) })) } static stopListeningToAll() { this.GlobalMessenger.stopListeningToAll() } static emit(e, t) { this.GlobalMessenger.emit(e, t) } } Object.defineProperties(Messenger, { GlobalMessenger: { value: new Messenger, writable: !1 }, EVENTS: { value: {}, writable: !1 } }); const h = Messenger; class AbstractHostFeature{ constructor(e) { this._host = e } installApi() { const e = {}, t = { EVENTS: e }; return Object.entries(this.constructor.EVENTS).forEach((([t, i]) => { e[t] = `${this.constructor.name}.${i}` })), this._host[this.constructor.name] = t, t } get host() { return this._host } get owner() { return this._host.owner } listenTo(e, t) { this._host.listenTo(e, t) } static listenTo(e, t) { e = `${this.name}.${e}`, h.listenTo(e, t) } stopListening(e, t) { this._host.stopListening(e, t) } static stopListening(e, t) { e = `${this.name}.${e}`, h.stopListening(e, t) } stopListeningByRegexp(e, t) { this._host.stopListeningByRegexp(e, t) } static stopListeningByRegexp(e, t) { e = new RegExp(`^${this.name}.${e.source.replace(/\^/, "")}`), h.stopListeningByRegexp(e, t) } stopListeningToAll() { this._host.stopListeningToAll() } static stopListeningToAll() { h.stopListeningByRegexp(new RegExp(`^${this.name}.`)) } emit(e, t) { e = `${this.constructor.name}.${e}`, this._host.emit(e, t) } static emit(e, t) { e = `${this.name}.${e}`, h.emit(e, t) } update(e) { this.emit(this.constructor.EVENTS.update, e) } discard() { Object.keys(this._host[this.constructor.name]).forEach((e => { delete this._host[this.constructor.name][e] })), delete this._host[this.constructor.name], delete this._host } static mix(...e) { let t = this; return e.forEach((e => { t = e(t) })), t } } Object.defineProperties(AbstractHostFeature, { EVENTS: { value: { update: "onUpdate" }, writable: !1 }, SERVICES: { value: {}, writable: !1 } }); const c = AbstractHostFeature; class HostObject extends h{ constructor({ owner: e = {} } = {}) { super(e.id), this._owner = e, this._features = {}, this._waits = [], this._lastUpdate = this.now } get owner() { return this._owner } get now() { return Date.now() } get deltaTime() { return this.now - this._lastUpdate } update() { const e = this.now, t = this.deltaTime; this._waits.forEach((e => { e.execute(t) })), Object.values(this._features).forEach((e => { e.update(t) })), this.emit(this.constructor.EVENTS.update, t), this._lastUpdate = e } wait(e, { onFinish: t, onProgress: i, onCancel: s, onError: a } = {}) { const r = n.wait(e, { onFinish: t, onProgress: i, onCancel: s, onError: a }); this._waits.push(r); const o = () => { this._waits.splice(this._waits.indexOf(r), 1) }; return r.then(o, o), r } addFeature(e, t = !1, ...i) { if ("function" !== typeof e) throw new Error(`Cannot add feature to host ${this.id}. FeatureClass must be a class.`); if (!(e.prototype instanceof c)) throw new Error(`Cannot add feature ${e.name} to host ${this.id}. FeatureClass must extend AbstractHostFeature.`); if (void 0 !== this._features[e.name]) { if (!t) throw new Error(`Feature ${e.name} already exists on host ${this.id}. Use 'force' argument to overwrite the feature.`); console.warn(`Feature ${e.name} already exists on host ${this.id}. Existing feature will be overwritten.`) } const s = new e(this, ...i); return s.installApi(), this._features[e.name] = s, this.emit(this.constructor.EVENTS.addFeature, e.name), !0 } removeFeature(e) { return void 0 === this._features[e] ? (console.warn(`Feature of type ${e} does not exist on host ${this.id}. No feature will be removed.`), !1) : (this.emit(this.constructor.EVENTS.removeFeature, e), this._features[e].discard(), delete this._features[e], !0) } hasFeature(e) { return !!this._features[e] } listFeatures() { return Object.keys(this._features) } } Object.defineProperty(HostObject, "EVENTS", { value: { ...Object.getPrototypeOf(HostObject).EVENTS, update: "onUpdate", addFeature: "onAddFeature", removeFeature: "onRemoveFeature" }, writable: !1 }); const l = HostObject, u = { None: e => e, In: e => e, Out: e => e, InOut: e => e }, d = { In: e => e * e, Out: e => e * (2 - e), InOut: e => (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1) }, m = { In: e => e * e * e, Out: e => --e * e * e + 1, InOut: e => (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2) }, _ = { In: e => e * e * e * e, Out: e => 1 - --e * e * e * e, InOut: e => (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2) }, p = { In: e => e * e * e * e * e, Out: e => --e * e * e * e * e + 1, InOut: e => (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2) }, g = { In: e => 1 - Math.cos(e * Math.PI / 2), Out: e => Math.sin(e * Math.PI / 2), InOut: e => .5 * (1 - Math.cos(Math.PI * e)) }, y = { In: e => 0 === e ? 0 : 1024 ** (e - 1), Out: e => 1 === e ? 1 : 1 - 2 ** (-10 * e), InOut: e => 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * 1024 ** (e - 1) : .5 * (2 - 2 ** (-10 * (e - 1))) }, f = { In: e => 1 - Math.sqrt(1 - e * e), Out: e => Math.sqrt(1 - --e * e), InOut: e => (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : (e -= 2, .5 * (Math.sqrt(1 - e * e) + 1)) }, v = { In(e) { let t, i = .1; return 0 === e ? 0 : 1 === e ? 1 : (!i || i < 1 ? (i = 1, t = .1) : t = .4 * Math.asin(1 / i) / (2 * Math.PI), -i * 2 ** (10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / .4)) }, Out(e) { let t, i = .1; return 0 === e ? 0 : 1 === e ? 1 : (!i || i < 1 ? (i = 1, t = .1) : t = .4 * Math.asin(1 / i) / (2 * Math.PI), i * 2 ** (-10 * e) * Math.sin((e - t) * (2 * Math.PI) / .4) + 1) }, InOut(e) { let t, i = .1; const s = .4; return 0 === e ? 0 : 1 === e ? 1 : (!i || i < 1 ? (i = 1, t = .1) : t = s * Math.asin(1 / i) / (2 * Math.PI), (e *= 2) < 1 ? i * 2 ** (10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / s) * -.5 : i * 2 ** (-10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / s) * .5 + 1) } }, E = { In(e) { const t = 1.70158; return e * e * ((t + 1) * e - t) }, Out(e) { const t = 1.70158; return --e * e * ((t + 1) * e + t) + 1 }, InOut(e) { const t = 2.5949095; return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * .5 : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2) } }, A = { In: e => 1 - A.Out(1 - e), Out: e => e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? (e -= 1.5) / 2.75 * 7.5625 * e + .75 : e < 2.5 / 2.75 ? (e -= 2.25) / 2.75 * 7.5625 * e + .9375 : (e -= 2.625) / 2.75 * 7.5625 * e + .984375, InOut: e => e < .5 ? .5 * A.In(2 * e) : .5 * A.Out(2 * e - 1) + .5 }; class FeatureDependentInterface{ _onFeatureAdded(e) { } _onFeatureRemoved(e) { } discard() { } static Mixin(e) { const t = class extends e{ constructor(e) { super(e), this._host = e, this._initialized || (this._initialized = !0, this._onFeatureAdded = this._onFeatureAdded.bind(this), this._onFeatureRemoved = this._onFeatureRemoved.bind(this), this._host.listenTo(l.EVENTS.addFeature, this._onFeatureAdded), this._host.listenTo(l.EVENTS.removeFeature, this._onFeatureRemoved), Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach((e => { void 0 !== this._host[e] && this._onFeatureAdded(e) }))) } _onFeatureAdded(e) { if (void 0 !== this.constructor.EVENT_DEPENDENCIES[e]) { const t = this.constructor.EVENT_DEPENDENCIES[e]; Object.entries(t).forEach((([t, i]) => { this[i] = this[i].bind(this), this._host.listenTo(this._host[e].EVENTS[t], this[i]) })) } } _onFeatureRemoved(e) { if (void 0 !== this.constructor.EVENT_DEPENDENCIES[e]) { const t = this.constructor.EVENT_DEPENDENCIES[e]; Object.entries(t).forEach((([t, i]) => { this._host.stopListening(this._host[e].EVENTS[t], this[i]) })) } } discard() { this._host.stopListening(l.EVENTS.addFeature, this._onFeatureAdded), this._host.stopListening(l.EVENTS.removeFeature, this._onFeatureRemoved), Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach((e => { void 0 !== this._host[e] && this._onFeatureRemoved(e) })), super.discard() } }, i = e.EVENT_DEPENDENCIES || {}; return Object.defineProperties(t, { EVENT_DEPENDENCIES: { value: { ...i }, writable: !1 } }), t } } Object.defineProperties(FeatureDependentInterface, { EVENT_DEPENDENCIES: { value: {}, writable: !1 } }); const S = FeatureDependentInterface; class AnimationFeatureDependentInterface extends S{ _onLayerAdded({ name: e }) { } _onLayerRemoved({ name: e }) { } _onLayerRenamed({ oldName: e, newName: t }) { } _onAnimationAdded({ layerName: e, animationName: t }) { } _onAnimationRemoved({ layerName: e, animationName: t }) { } _onAnimationRenamed({ layerName: e, oldName: t, newName: i }) { } static Mixin(e) { const t = S.Mixin(e), i = class extends t{ _onLayerAdded({ name: e }) { } _onLayerRemoved({ name: e }) { } _onLayerRenamed({ oldName: e, newName: t }) { } _onAnimationAdded({ layerName: e, animationName: t }) { } _onAnimationRemoved({ layerName: e, animationName: t }) { } _onAnimationRenamed({ layerName: e, oldName: t, newName: i }) { } }; return Object.defineProperties(i, { EVENT_DEPENDENCIES: { value: { ...t.EVENT_DEPENDENCIES, ...AnimationFeatureDependentInterface.EVENT_DEPENDENCIES }, writable: !1 } }), i } } Object.defineProperties(AnimationFeatureDependentInterface, { EVENT_DEPENDENCIES: { value: { AnimationFeature: { addLayer: "_onLayerAdded", removeLayer: "_onLayerRemoved", renameLayer: "_onLayerRenamed", addAnimation: "_onAnimationAdded", removeAnimation: "_onAnimationRemoved", renameAnimation: "_onAnimationRenamed" } }, writable: !1 } }); const b = AnimationFeatureDependentInterface; class ManagedAnimationLayerInterface extends b{ registerLayer(e, t = {}) { } registerAnimation(e, t, i = {}) { } setLayerWeights(e = (() => !0), t, i, s) { } enable(e, t) { } disable(e, t) { } static Mixin(e) { const t = b.Mixin(e), i = class extends t{ constructor(...e) { super(...e), this._managedLayers = {} } _onFeatureAdded(e) { super._onFeatureAdded(e), "AnimationFeature" === e && (this._managedLayers = this._managedLayers || {}, this._host.AnimationFeature.layers.forEach((e => { this._onLayerAdded({ name: e }) }))) } _onFeatureRemoved(e) { super._onFeatureRemoved(e), "AnimationFeature" === e && (this._managedLayers = this._managedLayers || {}, Object.keys(this._managedLayers).forEach((e => { this._onLayerRemoved({ name: e }) }))) } _onLayerAdded({ name: e }) { void 0 !== this._managedLayers[e] && (this._managedLayers[e].isActive = !0, this._host.AnimationFeature.getAnimations(e).forEach((t => { this._onAnimationAdded({ layerName: e, animationName: t }) }))) } _onLayerRemoved({ name: e }) { void 0 !== this._managedLayers[e] && (this._managedLayers[e].isActive = !1, Object.keys(this._managedLayers[e].animations).forEach((t => { this._onAnimationRemoved({ layerName: e, animationName: t }) }))) } _onLayerRenamed({ oldName: e, newName: t }) { const i = this._managedLayers[e]; void 0 !== i && (delete this._managedLayers[e], this._managedLayers[t] = i) } _onAnimationAdded({ layerName: e, animationName: t }) { void 0 !== this._managedLayers[e] && void 0 !== this._managedLayers[e].animations[t] && (this._managedLayers[e].animations[t].isActive = !0) } _onAnimationRemoved({ layerName: e, animationName: t }) { void 0 !== this._managedLayers[e] && void 0 !== this._managedLayers[e].animations[t] && (this._managedLayers[e].animations[t].isActive = !1) } _onAnimationRenamed({ layerName: e, oldName: t, newName: i }) { if (void 0 !== this._managedLayers[e] && void 0 !== this._managedLayers[e].animations[t]) { const s = this._managedLayers[e].animations[t]; delete this._managedLayers[e].animations[t], this._managedLayers[e].animations[i] = s } } registerLayer(e, t = {}) { void 0 === this._managedLayers[e] && (this._managedLayers[e] = { ...this.constructor.DEFAULT_LAYER_OPTIONS, animations: {} }); const i = this._managedLayers[e], s = (t = { ...t }).animations || {}; delete t.animations, Object.assign(i, t), i.isActive = void 0 !== this._host.AnimationFeature && this._host.AnimationFeature.layers.includes(e), Object.entries(s).forEach((([t, i]) => { this.registerAnimation(e, t, i) })) } registerAnimation(e, t, i = {}) { void 0 === this._managedLayers[e] && this.registerLayer(e); const s = this._managedLayers[e].animations[t] || {}; Object.assign(s, i), this._managedLayers[e].animations[t] = s, this._managedLayers[e].animations[t].isActive = this._managedLayers[e].isActive && this._host.AnimationFeature.getAnimations(e).includes(t) } setLayerWeights(e = (() => !0), t, i, s) { Object.keys(this._managedLayers).filter(e).forEach((e => { const n = this._managedLayers[e]; n.isActive && this._host.AnimationFeature.setLayerWeight(e, t, void 0 !== i ? i : n.blendTime, s || n.easingFn) })) } enable(e, t) { this.setLayerWeights(void 0, 1, e, t) } disable(e, t) { this.setLayerWeights(void 0, 0, e, t) } installApi() { const e = super.installApi(); return Object.assign(e, { registerLayer: this.registerLayer.bind(this), registerAnimation: this.registerAnimation.bind(this), setLayerWeights: this.setLayerWeights.bind(this), enable: this.enable.bind(this), disable: this.disable.bind(this) }), e } }; return Object.defineProperties(i, { DEFAULT_LAYER_OPTIONS: { value: ManagedAnimationLayerInterface.DEFAULT_LAYER_OPTIONS, writable: !1 } }), i } } Object.defineProperties(ManagedAnimationLayerInterface, { DEFAULT_LAYER_OPTIONS: { value: { blendTime: .5, animations: {} }, writable: !1 } }); const w = ManagedAnimationLayerInterface; class TextToSpeechFeatureDependentInterface extends S{ _onPlay() { } _onPause() { } _onResume() { } _onStop() { } _onSentence() { } _onWord() { } _onViseme() { } _onSsml() { } static Mixin(e) { const t = S.Mixin(e), i = class extends t{ _onPlay() { } _onPause() { } _onResume() { } _onStop() { } _onSentence() { } _onWord() { } _onViseme() { } _onSsml() { } }; return Object.defineProperties(i, { EVENT_DEPENDENCIES: { value: { ...t.EVENT_DEPENDENCIES, ...TextToSpeechFeatureDependentInterface.EVENT_DEPENDENCIES }, writable: !1 } }), i } } Object.defineProperties(TextToSpeechFeatureDependentInterface, { EVENT_DEPENDENCIES: { value: { TextToSpeechFeature: { play: "_onPlay", pause: "_onPause", resume: "_onResume", stop: "_onStop", sentence: "_onSentence", word: "_onWord", viseme: "_onViseme", ssml: "_onSsml" } }, writable: !1 } }); const T = TextToSpeechFeatureDependentInterface, L = { sil: { name: "sil" }, p: { name: "p", overrideWeight: .9 }, t: { name: "t", blendTime: .2 }, S: { name: "S" }, T: { name: "T" }, f: { name: "f", overrideWeight: .75 }, k: { name: "k" }, i: { name: "i" }, r: { name: "r" }, s: { name: "s", blendTime: .25 }, u: { name: "u" }, "@": { name: "@" }, a: { name: "a" }, e: { name: "e", blendTime: .2 }, E: { name: "E" }, o: { name: "o" }, O: { name: "O" } }; class LipsyncFeature extends (c.mix(T.Mixin, w.Mixin)) { constructor(e, { blendTime: t = .15, decayRate: { amount: i = .5, seconds: s = .5 } = {}, easingFn: n = d.InOut, layers: a = [] } = {}, { blendTime: r = .75, easingFn: o = d.InOut, layers: h = [] } = {}, c = .067) { super(e), this._visemeLayers = {}, this._talkingLayers = {}, this.visemeLeadTime = c, a.forEach((({ name: e, animation: a, visemeMap: r = L }) => { this.registerVisemeLayer(e, { animation: a, visemeMap: r, decayRate: { amount: i, seconds: s }, blendTime: t, easingFn: n }) })), h.forEach((({ name: e, animation: t }) => { this.registerTalkingLayer(e, { animation: t, blendTime: r, easingFn: o }) })) } _registerVisemeAnimation(e, t) { if (this._managedLayers[e].animations[t].isActive) if ("freeBlend" !== this._host.AnimationFeature.getAnimationType(e, t)) console.warn(`Cannot register Lipsync viseme animation ${t} on layer ${e} for host ${this._host.id}. Viseme animations must be of type 'freeBlend'.`), this._managedLayers[e].animations[t].isActive = !1; else { const i = this._host.AnimationFeature.getAnimationBlendNames(e, t), { visemeMap: s } = this._managedLayers[e].animations[t]; Object.values(s).forEach((e => { e.isActive = i.includes(e.name) })) } } _onFeatureAdded(e) { this._visemeLayers = this._visemeLayers || {}, this._talkingLayers = this._talkingLayers || {}, super._onFeatureAdded(e), "TextToSpeechFeature" === e && (this._host.TextToSpeechFeature.speechmarkOffset = -this._visemeLeadTime || 0) } _onLayerAdded({ name: e }) { super._onLayerAdded({ name: e }), void 0 !== this._visemeLayers[e] && this._registerVisemeAnimation(e, this._visemeLayers[e]) } _onAnimationAdded({ layerName: e, animationName: t }) { super._onAnimationAdded({ layerName: e }), this._visemeLayers[e] === t && this._registerVisemeAnimation(e, this._visemeLayers[e]) } _onPlay() { this.enable(), [this._visemeLayers, this._talkingLayers].forEach((e => { Object.entries(e).forEach((([e, t]) => { this._managedLayers[e].animations[t].isActive && this._host.AnimationFeature.resumeAnimation(e, t) })) })) } _onPause() { this._onStop() } _onResume() { this._onPlay() } _onStop() { this.disable(), [this._visemeLayers, this._talkingLayers].forEach((e => { Object.entries(e).forEach((([e, t]) => { this._managedLayers[e].animations[t].isActive && this._host.AnimationFeature.pauseAnimation(e, t) })) })) } async _onViseme({ mark: e }) { Object.entries(this._visemeLayers).forEach((([t, i]) => { const { isActive: s, visemeMap: n } = this._managedLayers[t].animations[i]; if (!s) return; const { name: a, isActive: r, decayRate: h, blendTime: c, easingFn: l, overrideWeight: u } = { ...this._managedLayers[t], ...n[e.value] }, d = this._host.AnimationFeature.getAnimationBlendNames(t, i); if (!r || !d.includes(a)) return; let m = 1; const _ = e.duration / 1e3; if (_ < c) { const e = c > 0 ? _ / c : 1; m = void 0 !== u ? u : o.lerp(0, 1, e) } const p = Math.min(_, c), g = _ - c; if (g < 0) this._animateSimpleViseme(t, i, a, m, p, c, l); else { const e = h.seconds > 0 ? g / h.seconds : 1, s = o.lerp(m, m * h.amount, Math.min(1, e)); this._animateHeldViseme(t, i, a, m, s, p, g, c, l) } })) } _animateSimpleViseme(e, t, i, s, n, a, r) { const o = this._host.AnimationFeature.setAnimationBlendWeight(e, t, i, s, n, r); o.then((() => { o.canceled || this._host.AnimationFeature.setAnimationBlendWeight(e, t, i, 0, a, r) })) } async _animateHeldViseme(e, t, i, s, n, a, r, o, h) { const c = this._host.AnimationFeature.setAnimationBlendWeight(e, t, i, s, a, h); if (await c, !c.canceled) { const s = this._host.AnimationFeature.setAnimationBlendWeight(e, t, i, n, r, h); await s, s.canceled || this._host.AnimationFeature.setAnimationBlendWeight(e, t, i, 0, o, h) } } get visemeLeadTime() { return this._visemeLeadTime } set visemeLeadTime(e) { this._visemeLeadTime = e, this._host.TextToSpeechFeature && (this._host.TextToSpeechFeature.speechmarkOffset = -e) } registerVisemeLayer(e, { animation: t = "visemes", decayRate: i = { amount: .5, seconds: .5 }, blendTime: s = LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime, easingFn: n, visemeMap: a = L } = {}) { this.registerLayer(e, { decayRate: i, blendTime: s, easingFn: n, animations: { [t]: { visemeMap: a } } }), this._visemeLayers[e] = t, this._registerVisemeAnimation(e, t) } registerTalkingLayer(e, { animation: t = "stand_talk", blendTime: i = LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime, easingFn: s } = {}) { this.registerLayer(e, { blendTime: i, easingFn: s, animations: { [t]: {} } }), this._talkingLayers[e] = t } installApi() { const e = super.installApi(); return Object.assign(e, { registerVisemeLayer: this.registerVisemeLayer.bind(this), registerTalkingLayer: this.registerTalkingLayer.bind(this) }), Object.defineProperty(e, "visemeLeadTime", { get: () => this.visemeLeadTime, set: e => { this.visemeLeadTime = e } }), e } } const x = LipsyncFeature; const N = class SSMLSpeechmarkInterface extends T{ _onSsml({ mark: e }) { } static Mixin(e) { const t = T.Mixin(e); return class extends t{ _onSsml({ mark: e }) { try { const { feature: t, method: i, args: s } = JSON.parse(e.value); if (this.constructor.name === t) { const e = this[i]; e && "function" == typeof e ? e.apply(this, s) : console.warn(`Function ${i} does not exist within feature ${t}`) } } catch (e) { } } } } }, F = { big: ["add", "above", "authority", "big", "cover", "full", "fly", "grow", "growth", "high", "huge", "increase", "major", "majority", "large", "leader", "lot", "raise", "rise", "tall"], heart: ["accept", "admit", "believe", "care", "feeling", "feel", "friend", "grateful", "happy", "heart", "human", "pain", "save", "safe", "kind", "love"], in: ["include", "including", "inside", "into", "now", "near", "nearest", "closest", "therein", "within"], many: ["all", "always", "any", "anyone", "among", "area", "around", "beautiful", "entire", "environment", "environments", "environmental", "everybody", "everyone", "everything", "audience", "total", "group", "groups", "million", "millions", "others", "billion", "billions", "hundred", "hundreds", "many", "thousand", "thousands", "world", "worlds", "outside", "reveal"], movement: ["away", "across", "ahead", "along", "far", "fast", "follow", "go", "leave", "move", "movement", "through", "throughout", "toward", "travel", "turned", "passed"], one: ["single", "one", "once", "first", "firstly", "only", "solo", "warned", "truly", "up", "alone"], aggressive: ["power", "powers", "powerful", "assert", "assertive", "strong", "stronger", "strongest", "strength", "flex", "dang", "damn", "damnit", "darn", "shucks", "doh", "drat", "angry", "angrier", "angriest", "aggressive", "annoyed", "annoying", "attack", "attacking", "offense", "offensive", "battle"], you: ["you", "yall", "y'all", "your", "yours", "thou", "thy"], defense: ["defense", "fear", "repulsed", "scared", "scary", "scarier", "scariest", "fearful", "afraid", "cower", "cowers", "cowering", "hideous", "doomed", "terrified", "terrify", "terrifying", "terrifies", "spooky", "spookier", "spookiest"], wave: ["hello", "hi", "hiya", "howdy", "welcome", "aloha", "heya", "hey", "bye", "goodbye", "hola", "adios", "chao"], self: ["my", "I", "myself", "self", "I've", "Ive", "me", "mine", "own"] }; class GestureFeature extends (c.mix(N.Mixin, w.Mixin)) { constructor(e, { holdTime: t = 3, minimumInterval: i = 1, layers: s = {} } = {}) { super(e), this.holdTime = t, this.minimumInterval = i, Object.entries(s).forEach((([e, t = {}]) => { this.registerLayer(e, t) })) } _getHoldTime(e, t) { const i = void 0 !== e.holdTime ? e.holdTime : this.holdTime; return void 0 !== t.holdTime ? t.holdTime : i } _getMinimumInterval(e, t) { const i = void 0 !== e.minimumInterval ? e.minimumInterval : this.minimumInterval; return void 0 !== t.minimumInterval ? t.minimumInterval : i } _onNext({ layerName: e, animationName: t, canAdvance: i, isQueueEnd: s }) { const a = this._managedLayers[e]; if (void 0 === a) return; const r = a.animations[t]; if (void 0 !== r && !i && !s && a.currentGesture === t) { const i = this._getHoldTime(a, r); a.holdTimer.cancel(), i <= 0 ? this._host.AnimationFeature.playNextAnimation(e, t) : a.holdTimer = n.wait(i, { onFinish: () => { a.currentGesture === t && this._host.AnimationFeature.playNextAnimation(e, t) } }) } } _onStop({ layerName: e, animationName: t }) { const i = this._managedLayers[e]; if (void 0 === i) return; void 0 !== i.animations[t] && t === i.currentGesture && (i.currentGesture = null, i.playTimer = null, i.holdTimer.cancel(), i.autoDisable && this.setLayerWeights((t => t === e), 0)) } _onAnimationAdded({ layerName: e, animationName: t }) { const i = this._managedLayers[e]; if (void 0 !== i) { const s = i.animations[t]; void 0 === s ? this.registerAnimation(e, t) : s.isActive = !0 } } registerLayer(e, t = {}) { super.registerLayer(e, { ...t, holdTimer: s.resolve(), playTimer: null, currentGesture: null }), this._managedLayers[e].isActive && this._host.AnimationFeature.getAnimations(e).forEach((t => { void 0 === this._managedLayers[e].animations[t] && this.registerAnimation(e, t, this._managedLayers[e].animations[t]) })) } registerAnimation(e, t, i = {}) { i.words instanceof Array || i.words instanceof Set || (i.words = F[t] || []), super.registerAnimation(e, t, i) } createGestureMap() { const e = {}; return Object.entries(this._managedLayers).forEach((([t, { animations: i }]) => { Object.entries(i).forEach((([i, { holdTime: s, minimumInterval: n, words: a, transitionTime: r }]) => { if (a.length) { const o = { ...s && { holdTime: s }, ...n && { minimumInterval: n }, ...r && { transitionTime: r } }, h = { feature: this.constructor.name, method: "playGesture", args: [t, i, o] }; e[JSON.stringify(h)] = a } })) })), e } createGenericGestureArray(e) { const t = []; return (e = e || Object.keys(this._managedLayers)).forEach((e => { const i = this._managedLayers[e]; i && Object.entries(i.animations).forEach((([i, { holdTime: s, minimumInterval: n, words: a, transitionTime: r }]) => { if (!a.length) { const a = { ...s && { holdTime: s }, ...n && { minimumInterval: n }, ...r && { transitionTime: r } }, o = JSON.stringify({ feature: this.constructor.name, method: "playGesture", args: [e, i, a] }); t.includes(o) || t.push(o) } })) })), t } playGesture(e, t, { holdTime: i, minimumInterval: n, transitionTime: a, force: r = !1 } = {}) { void 0 !== this._managedLayers[e] && void 0 !== this._managedLayers[e].animations[t] || this.registerAnimation(e, t, { holdTime: i, minimumInterval: n, transitionTime: a }); const o = this._managedLayers[e], h = o.animations[t]; if (!h.isActive) { const i = o.isActive ? "animation" : "layer", n = `Skipping gesture ${t} on layer ${e} for host ${this._host.id}. No ${i} exists with this name yet.`; return console.warn(n), s.cancel({ reason: "inactive", value: i }) } const { currentGesture: c } = o; if (c === t && !r) { const i = `Skipping gesture ${t} on layer ${e} for host ${this._host.id}. The gesture is already playing. Use options.force to force the gesture replay, which may result in a hard transition.`; return console.warn(i), s.cancel({ reason: "playing", value: t }) } return void 0 !== i && (h.holdTime = i), void 0 !== n ? h.minimumInterval = n : n = this._getMinimumInterval(o, h), !r && null !== o.playTimer && o.playTimer < n ? (console.warn(`Skipping gesture ${t} on layer ${e} for host ${this._host.id}. Minimum interval ${n} has not been met.`), s.cancel({ reason: "minimumInterval", value: n - o.playTimer })) : (o.currentGesture = t, o.playTimer = 0, o.holdTimer.cancel(), o.autoDisable && this.setLayerWeights((t => t === e), 1), this._host.AnimationFeature.playAnimation(e, t, a)) } update(e) { super.update(e), Object.entries(this._managedLayers).forEach((([t, i]) => { i.isActive && !this._host.AnimationFeature.getPaused(t) && (i.holdTimer.execute(e), null !== i.playTimer && (i.playTimer += e / 1e3)) })) } installApi() { const e = super.installApi(); Object.assign(e, { createGestureMap: this.createGestureMap.bind(this), createGenericGestureArray: this.createGenericGestureArray.bind(this), playGesture: this.playGesture.bind(this) }) } } Object.defineProperties(GestureFeature, { DEFAULT_LAYER_OPTIONS: { value: { ...GestureFeature.DEFAULT_LAYER_OPTIONS, autoDisable: !0 }, writable: !1 }, EVENT_DEPENDENCIES: { value: { ...GestureFeature.EVENT_DEPENDENCIES, AnimationFeature: { ...GestureFeature.EVENT_DEPENDENCIES.AnimationFeature, playNextAnimation: "_onNext", stopAnimation: "_onStop", interruptAnimation: "_onStop" } } } }); const M = GestureFeature; const O = class AnimationUtils{ static lerp(e, t, i) { return console.warn("AnimationUtils.lerp is being deprecated. Use MathUtils.lerp instead."), o.lerp(e, t, i) } static clamp(e, t = 0, i = 1) { return console.warn("AnimationUtils.clamp is being deprecated. Use MathUtils.clamp instead."), o.clamp(e, t, i) } static interpolateProperty(e, t, i, { seconds: a = 0, easingFn: r, onFinish: h, onProgress: c, onCancel: l, onError: d } = {}) { if (!(e instanceof Object)) { const e = new Error(`Cannot interpolate property ${t}. Property owner must be an object.`); return "function" == typeof d && d(e), s.reject(e) } if (Number.isNaN(Number(e[t]))) { const e = new Error(`Cannot interpolate property ${t}. Property must be numeric.`); return "function" == typeof d && d(e), s.reject(e) } if (Number.isNaN(Number(i))) { const e = new Error(`Cannot interpolate property ${t} to value ${i}. Target value must be numeric.`); return "function" == typeof d && d(e), s.reject(e) } const m = e[t]; if (m === i) return "function" == typeof h && h(i), s.resolve(i); "function" != typeof r && (void 0 !== r && console.warn("Invalid property interpolation easingFn. Defaulting to linear interpolation."), r = u.InOut); const _ = n.wait(a, { onFinish: () => { e[t] = i, "function" == typeof h && h(i) }, onCancel: () => { "function" == typeof l && l(e[t]) }, onProgress: s => { if (e[t] !== i) { const n = r(s); if ("number" != typeof n) { const e = new Error("Invalid property interpolation easingFn. EasingFn must return a number."); return void _.reject(e) } e[t] = o.lerp(m, i, n) } "function" == typeof c && c(e[t]), 1 === s && (e[t] = i, _.resolve(i)) }, onError: d }); return _ } }; const C = class AbstractState{ constructor(e = {}) { this.name = void 0 !== e.name ? e.name : this.constructor.name, this._weight = void 0 !== e.weight ? o.clamp(e.weight, 0, 1) : 0, this._internalWeight = this._weight, this._paused = !1, this._promises = { finish: s.resolve(), weight: s.resolve(), play: s.resolve() }, this._playCallbacks = { onFinish: void 0, onError: void 0, onCancel: void 0 } } get paused() { return this._paused } get weight() { return this._weight } set weight(e) { this._weight = o.clamp(e, 0, 1) } get weightPending() { return this._promises.weight && this._promises.weight.pending } setWeight(e, t = 0, i) { return this._promises.weight.cancel(), e = o.clamp(e), this._promises.weight = O.interpolateProperty(this, "weight", e, { seconds: t, easingFn: i }), this._promises.weight } get internalWeight() { return this._internalWeight } updateInternalWeight(e) { this._internalWeight = this._weight * e } update(e) { this._paused || Object.values(this._promises).forEach((t => { t.execute(e) })) } play(e, t, i) { return this._paused = !1, this._playCallbacks.onFinish = e, this._playCallbacks.onError = t, this._playCallbacks.onCancel = i, this._promises.play = new s(void 0, e, t, i), this._promises.finish = s.all([this._promises.play, this._promises.weight]), this._promises.finish } pause() { return this._paused = !0, !0 } resume(e, t, i) { return this._paused = !1, this._promises.play.pending || (this._playCallbacks.onFinish = e || this._playCallbacks.onFinish, this._playCallbacks.onError = t || this._playCallbacks.onError, this._playCallbacks.onCancel = i || this._playCallbacks.onCancel, this._promises.play = new s(void 0, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel), this._promises.finish = s.all([this._promises.play, this._promises.weight])), this._promises.finish } cancel() { return this._paused = !0, Object.values(this._promises).forEach((e => { e.cancel() })), !0 } stop() { return this._paused = !0, Object.values(this._promises).forEach((e => { e.resolve() })), !0 } discard() { this.cancel(), delete this._promises } deactivate() { this.updateInternalWeight(0) } }; const k = class TransitionState extends C{ constructor(e = {}) { super(e), this._to = null, this._from = [], this._weightPromise = s.resolve() } get internalWeight() { let e = 0; return this._to && (e += this._to.weight), this._from.forEach((t => { e += t.weight })), e * this._internalWeight } updateInternalWeight(e) { super.updateInternalWeight(e), this._from.forEach((e => { e.updateInternalWeight(this._internalWeight) })), this._to && this._to.updateInternalWeight(this._internalWeight) } configure(e = [], t, i, s, n) { (this._to === t || e.includes(this._to)) && (this._to = null), this._from = this._from.filter((i => i !== t && !e.includes(i))), this.deactivate(), this._from = e, this._to = t, this.reset(i, s, n) } reset(e, t, i) { this._weightPromise.cancel(); const n = this._from.map((i => i.setWeight(0, e, t))); this._to ? (n.push(this._to.setWeight(1, e, t)), this.name = this._to.name) : this.name = null, this._weightPromise = s.all(n, (() => { this._from.forEach((e => { e.cancel(), e.deactivate() })), "function" == typeof i && i() })) } play(e, t, i, n) { this._paused = !1, this._playCallbacks.onFinish = e, this._playCallbacks.onError = t, this._playCallbacks.onCancel = i; const a = [this._weightPromise]; return this._from.forEach((e => { e.resume() })), this._to && (this._promises.play = this._to.play(void 0, void 0, void 0, n), a.push(this._promises.play)), this._promises.finish = s.all(a, e, t, i), this._promises.finish } pause() { return this._from.forEach((e => { e.pause() })), this._to && this._to.pause(), super.pause() } resume(e, t, i, n) { this._paused = !1, this._promises.play.pending || (this._playCallbacks.onFinish = e || this._playCallbacks.onFinish, this._playCallbacks.onError = t || this._playCallbacks.onError, this._playCallbacks.onCancel = i || this._playCallbacks.onCancel); const a = [this._weightPromise]; return this._from.forEach((e => { e.resume() })), this._to && (this._promises.play = this._to.resume(void 0, void 0, void 0, n), a.push(this._promises.play)), this._promises.finish = s.all(a, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel), this._promises.finish } cancel() { return this._from.forEach((e => { e.pause() })), this._to && this._to.cancel(), this._weightPromise.cancel(), super.cancel() } stop() { return this._from.forEach((e => { e.pause() })), this._to && this._to.stop(), super.stop() } update(e) { super.update(e), this._from.forEach((t => { t.update(e) })), this._to && this._to.update(e) } discard() { super.discard(), this._weightPromise.cancel(), delete this._weightPromise, this._to = null, this._from.length = 0 } deactivate() { this._to && this._to.deactivate(), this._from.forEach((e => { e.deactivate() })) } }; const I = class AnimationPlayerInterface{ get paused() { return this._paused } get transitionTime() { } set transitionTime(e) { } get easingFn() { } set easingFn(e) { } get currentState() { } get currentAnimation() { } get isTransitioning() { } _prepareCurrentState(e, t, i, s, n) { } playAnimation(e, t, i, s, n, a, r) { } cancelAnimation() { } pauseAnimation() { } resumeAnimation(e, t, i, s, n, a, r) { } stopAnimation() { } update(e) { } discard() { } static Mixin(e = class { }) { return class extends e{ constructor(e = {}, ...t) { super(e, ...t), this._transitionState = new k, this._states = void 0 !== this._states ? this._states : new Map, this._currentState = null, this._paused = !1, this._transitionTime = Number(e.transitionTime) >= 0 ? Number(e.transitionTime) : 0, this._easingFn = "function" == typeof e.easingFn ? e.easingFn : void 0 } get paused() { return this._paused } get transitionTime() { return this._transitionTime } set transitionTime(e) { if (!((e = Number(e)) >= 0)) throw new Error(`Cannot set transition time for ${this.constructor.name} to ${e}. Seconds must be a numeric value greather than or equal to zero.`); this._transitionTime = e } get easingFn() { return this._easingFn } set easingFn(e) { this._easingFn = e } get currentState() { return this._currentState } get currentAnimation() { return this._currentState ? this._currentState.name : null } get isTransitioning() { return this._currentState === this._transitionState } _prepareCurrentState(e, t, i, s, n) { if (null !== e && !this._states.has(e)) { const i = new Error(`Cannot ${t} animation ${e}. No animation exists with this name.`); throw "function" == typeof n && n(i), i } const a = null !== e ? this._states.get(e) : null; if (this.currentAnimation !== e) if (i <= 0) this._currentState && (this._currentState.cancel(), this._currentState.weight = 0, this._currentState.deactivate()), this._currentState = a; else { const e = [...this._states.values()].filter((e => e !== a && (e.weight || e.weightPending))); this._transitionState.configure(e, a, i, s, (() => { this._currentState = a, this._transitionState.weight = 0 })), this._currentState = this._transitionState } else "play" === t && (this._currentState.cancel(), this._currentState === this._transitionState && this._transitionState.reset(i, s, (() => { this._currentState = a, this._transitionState.weight = 0 }))); this._currentState.weight = 1, this._currentState.updateInternalWeight(this._internalWeight) } playAnimation(e, t, i, n, a, r, o) { let h, c = !1; try { this._prepareCurrentState(e, "play", void 0 !== t ? t : this._transitionTime, void 0 !== i ? i : this._easingFn, a) } catch (e) { h = e, c = !0 } return c ? s.reject(h) : this._currentState.play(n, a, r, o) } pauseAnimation() { return !!this._currentState && this._currentState.pause() } resumeAnimation(e, t, i, n, a, r, o) { let h; void 0 === e && this._currentState && (e = this._currentState.name); let c = !1; try { this._prepareCurrentState(e, "resume", void 0 !== t ? t : this._transitionTime, void 0 !== i ? i : this._easingFn, a) } catch (e) { h = e, c = !0 } return c ? s.reject(h) : this._currentState.resume(n, a, r, o) } cancelAnimation() { return !!this._currentState && this._currentState.cancel() } stopAnimation() { return !!this._currentState && this._currentState.stop() } update(e) { super.update && super.update(e), this._currentState && this._currentState.update(e) } discard() { super.discard && super.discard(), this._transitionState.discard(), delete this._transitionState } } } }; const P = class StateContainerInterface{ getState(e) { } getStateNames() { } addState(e) { } removeState(e) { } renameState(e, t) { } discardStates() { } static Mixin(e = class { }) { return class extends e{ constructor(e = {}, ...t) { super(e, ...t), this._states = void 0 !== this._states ? this._states : new Map } getState(e) { return this._states.get(e) } getStateNames() { return [...this._states.keys()] } addState(e) { if ([...this._states.values()].includes(e)) return console.warn(`Cannot add animation to state ${this.name}. Animation was already added.`), e.name; const t = n.getUniqueName(e.name, [...this._states.keys()]); return e.name !== t && (console.warn(`Animation name ${e.name} is not unique for state ${this.name}. New animation will be added with name ${t}.`), e.name = t), this._states.set(e.name, e), e.name } removeState(e) { return this._states && this._states.has(e) ? (this._states.get(e).discard(), this._states.delete(e), !0) : (console.warn(`Did not remove animation ${e} from state ${this.name}. No animation exists with this name.`), !1) } renameState(e, t) { if (!this._states || !this._states.has(e)) throw new Error(`Cannot rename animation ${e} in ${this.name}. No animation exists with this name.`); const i = this._states.get(e); if (e === t) return e; const s = n.getUniqueName(t, [...this._states.keys()].filter((t => t.name !== e))); return t !== s && (console.warn(`Animation name ${t} is not unique in state ${this.name}. Animation will be renamed to ${s}.`), t = s), i.name = t, this._states.delete(e), this._states.set(i.name, i), i.name } discardStates() { this._states.forEach((e => { e.discard() })), delete this._states } } } }; class QueueState extends (I.Mixin(P.Mixin(C))) { constructor(e = {}, t = []) { super(e), t.forEach((e => { this.addState(e) })), this._queue = this._states.keys(), this._done = !0 } get done() { return this._done } get internalWeight() { return this._currentState ? this._currentState.internalWeight * this._internalWeight : 0 } _reset() { this._queue = this._states.keys(); const { value: e, done: t } = this._queue.next(); return this._done = t, e || null } updateInternalWeight(e) { super.updateInternalWeight(e), this._currentState && this._currentState.updateInternalWeight(this._internalWeight) } next(e, t = !1) { const { value: i, done: s } = this._queue.next(); if (this._done = s, this._paused = !1, s) return t ? this.play(this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel, e) : (this._promises.finish.resolve(), this._promises.finish); if ("function" == typeof e) { const t = i === [...this._states.keys()][this._states.size - 1]; e({ name: i, canAdvance: this.getState(i).loopCount !== 1 / 0 && !t, isQueueEnd: t }) } return this.playAnimation(i, this._transitionTime, this._easingFn, (() => { this._paused || this.isTransitioning || this.next(e) }), this._playCallbacks.onError), this._promises.finish } play(e, t, i, s) { const n = this._reset(); if (super.play(e, t, i), this._done) this._promises.finish.resolve(); else { if (n !== this.currentAnimation && "function" == typeof s) { const e = n === [...this._states.keys()][this._states.size - 1]; s({ name: n, canAdvance: !n || this.getState(n).loopCount !== 1 / 0 && !e, isQueueEnd: !n || e }) } this.playAnimation(n, this._currentState ? this._transitionTime : 0, this._easingFn, (() => { this._paused || this.isTransitioning || this.next(s) }), t) } return this._promises.finish } pause() { const e = super.pause(); return this.pauseAnimation(), e } resume(e, t, i, s) { return this._done ? this.play(e, t, i, s) : (super.resume(e, t, i), this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, (() => { this._paused || this.isTransitioning || this.next(s) }), t), this._promises.finish) } cancel() { const e = super.cancel(); return this._currentState && this._currentState.cancel(), e } stop() { const e = super.stop(); return this.stopAnimation(), this._done = !0, e } discard() { super.discard(), this.discardStates() } } const $ = QueueState; class AbstractBlendState extends (P.Mixin(C)) { constructor(e = {}, t = [], ...i) { super(e, ...i), t.forEach((e => { this.addState(e) })) } get internalWeight() { let e = 0; return this._states.forEach((t => { e += t.internalWeight })), e } getBlendWeight(e) { const t = this.getState(e); if (void 0 === t) throw new Error(`Cannot get weight of state ${e} from BlendState ${this.name}. No state exists with this name.`); return t.weight } setBlendWeight(e, t, i = 0, s) { const n = this.getState(e); if (void 0 === n) throw new Error(`Cannot set weight of state ${e} from BlendState ${this.name}. No state exists with this name.`); return t = o.clamp(t), n.setWeight(t, i, s) } updateInternalWeight(e) { super.updateInternalWeight(e), this._states.forEach((e => { e.updateInternalWeight(this._internalWeight) })) } update(e) { super.update(e), this._states.forEach((t => { t.update(e) })) } play(e, t, i) { const n = [super.play()]; return this._states.forEach((e => { n.push(e.play()) })), s.all(n, e, t, i) } pause() { return this._states.forEach((e => { e.pause() })), super.pause() } resume(e, t, i) { const n = [super.resume()]; return this._states.forEach((e => { n.push(e.resume()) })), s.all(n, e, t, i) } cancel() { return this._states.forEach((e => { e.cancel() })), super.cancel() } stop() { return this._states.forEach((e => { e.stop() })), super.stop() } discard() { super.discard(), this.discardStates() } } const V = AbstractBlendState; const R = class FreeBlendState extends V{ constructor(e = {}, t = []) { super(e, t) } updateInternalWeight(e) { super.updateInternalWeight(e); let t = 0; this._states.forEach((e => { t += e.weight })), e /= Math.max(t, 1), this._states.forEach((t => { t.updateInternalWeight(e * this._weight) })) } }; const W = class Blend1dState extends V{ constructor(e = {}, t = [], i = [], n = []) { super(e, t), this._blendValue = 0, this._promises = { ...this._promises, blendValue: s.resolve() }; if (0 !== t.length && t.length !== i.length) throw new Error(`Cannot create Blend1dState with blendThresholds ${i}. BlendThresholds count does not match blendStates count.`); if (new Set(i).size !== i.length) throw new Error(`Cannot create Blend1dState with blendThresholds ${i}. BlendThresholds contains duplicate values`); this._thresholds = [], [...this._states.values()].forEach(((e, t) => { this._thresholds.push({ value: i[t], name: e.name, phaseMatch: n[t] || !1 }) })), this._sortThresholds(), this._forceNoThresholdDupes = !0, this._phaseLeadState = null, this._updateBlendWeights() } get blendValue() { return this._blendValue } set blendValue(e) { this._blendValue = e } get blendValuePending() { return this._promises.blendValue && this._promises.blendValue.pending } setBlendWeight(e, t, i = 0, s) { return this._promises.blendValue.cancel(), this._promises.blendValue = O.interpolateProperty(this, "blendValue", t, { seconds: i, easingFn: s, onProgress: () => { this._updateBlendWeights() }, onFinish: () => { this._updateBlendWeights() } }), this._promises.blendValue } getBlendWeight() { return this.blendValue } addState(e, t = 0, i = !1) { this._thresholds = this._thresholds || []; const s = this._thresholds.find((e => e.value === t)); if (this._forceNoThresholdDupes && void 0 !== s) throw new Error(`Cannot set blend threshold of ${t} for state ${e.name} on ${this.name}. A state already exists with that threshold.`); return super.addState(e), this._thresholds.push({ value: t, name: e.name, phaseMatch: i || !1 }), this._sortThresholds(), e.name } removeState(e) { const t = super.removeState(e); if (t) { const t = this._thresholds.findIndex((t => t.name === e)); this._thresholds.splice(t, 1) } return t } renameState(e, t) { t = super.renameState(e, t); return this._thresholds.find((t => t.name === e)).name = t, t } getBlendThreshold(e) { const t = this._thresholds.find((t => t.name === e)); if (void 0 === t) throw new Error(`Cannot get blend threshold of state ${e} on ${this.name}. No state exists with that name.`); return t.value } setBlendThreshold(e, t) { const i = this._thresholds.find((e => e.value === t)); if (void 0 !== i) throw new Error(`Cannot set blend threshold of ${t} for state ${e} on ${this.name}. A state already exists with that threshold.`); const s = this._thresholds.find((t => t.name === e)); if (void 0 === s) throw new Error(`Cannot set blend threshold of state ${e} on ${this.name}. No state exists with that name.`); return s.value = t, this._sortThresholds(), s.value } updateInternalWeight(e) { super.updateInternalWeight(e), this._phaseLeadState && this._states.forEach((e => { 0 !== e.weight && (e.normalizedTime = this._phaseLeadState.normalizedTime) })) } _updateBlendWeights() { if (0 === this._thresholds.length) return; if (1 === this._thresholds.length) { return void this._states.get(this._thresholds[0].name).setWeight(1) } this._states.forEach((e => { e.setWeight(0) })), this._phaseLeadState = null; let e = this._thresholds.findIndex((e => e.value >= this._blendValue)); if (0 === e || -1 === e) { e = -1 === e ? this._thresholds.length - 1 : 0; this._states.get(this._thresholds[e].name).setWeight(1) } else { const t = this._thresholds[e - 1], i = this._thresholds[e], s = (this.blendValue - t.value) / (i.value - t.value), n = 1 - s, a = this._states.get(t.name), r = this._states.get(i.name); a.setWeight(n), r.setWeight(s), t.phaseMatch && i.phaseMatch && (this._phaseLeadState = n > s ? a : r) } } _sortThresholds() { this._thresholds.sort(((e, t) => e.value - t.value)) } }; const j = class Blend2dState extends V{ constructor(e = {}, t = [], i = [], n = []) { if (super(e, t), t.length !== i.length) throw new Error(`Cannot create Blend2dState with blendStates ${t} and blendThresholds ${i}. Count of blendStates must match count of blendThresholds.`); i.slice(0, i.length - 1).forEach(((e, t) => { i.slice(t + 1).forEach((t => { if (e[0] === t[0] && e[1] === t[1]) throw new Error(`Cannot create Blend2dState with blendThresholds ${i}. No duplicate values allowed in blendThresholds.`) })) })), this._blendValueX = 0, this._blendValueY = 0, this._promises = { ...this._promises, blendValueX: s.resolve(), blendValueY: s.resolve() }, this._thresholds = [], [...this._states.values()].forEach(((e, t) => { this._thresholds.push({ name: e.name, phaseMatch: n[t] || !1 }) })), this._vertices = i, this._vertices.length >= 3 && (this._triangles = o.getDelaunayTriangulation(this._vertices)), this._phaseLeadState = null, this._updateBlendWeights() } setBlendWeight(e, t, i = 0, s) { const n = `blendValue${e.toUpperCase()}`; if ("blendValueX" !== n && "blendValueY" !== n) throw new Error(`Cannot set blend weight for ${e} on ${this.name}. Blend2dState only accepts 'X' or 'Y' for setBlendWeight`); return this._promises[n].cancel(), this._promises[n] = O.interpolateProperty(this, n, t, { seconds: i, easingFn: s, onProgress: () => { this._updateBlendWeights() }, onFinish: () => { this._updateBlendWeights() } }), this._promises[n] } getBlendWeight(e) { const t = e.toUpperCase(); if ("X" !== t && "Y" !== t) throw new Error(`Cannot get blend weight for ${e} on ${this.name}. Blend2dState only accepts 'X' or 'Y' for getBlendWeight`); return "X" === t ? this._blendValueX : this._blendValueY } get blendValueX() { return this._blendValueX } set blendValueX(e) { this._blendValueX = e } get blendValueY() { return this._blendValueY } set blendValueY(e) { this._blendValueY = e } get blendValueXPending() { return this._promises.blendValueX && this._promises.blendValueX.pending } get blendValueYPending() { return this._promises.blendValueY && this._promises.blendValueY.pending } updateInternalWeight(e) { super.updateInternalWeight(e), this._phaseLeadState && [...this._states.values()].forEach(((e, t) => { 0 !== e.weight && this._thresholds[t].phaseMatch && (e.normalizedTime = this._phaseLeadState.normalizedTime) })) } _updateBlendWeights() { if (!this._vertices || 0 === this._vertices.length) return; if (1 === this._vertices.length) return void ([...this._states.values()][0].weight = 1); this._states.forEach((e => { e.setWeight(0) })), this._phaseLeadState = null; const e = [this._blendValueX, this._blendValueY]; if (2 === this._vertices.length) this._setInfluenceClosestPointOnLine(e); else { const t = this._triangles.find((t => o.isPointInTriangle(this._vertices[t[0]], this._vertices[t[1]], this._vertices[t[2]], e))); t ? this._setInfluenceTriangle(t, e) : this._setInfluenceClosestPointInTriangles(e) } } _setInfluenceTriangle(e, t) { const i = o.triangleArea(this._vertices[e[1]], this._vertices[e[2]], t), s = o.triangleArea(this._vertices[e[0]], this._vertices[e[2]], t), n = o.triangleArea(this._vertices[e[0]], this._vertices[e[1]], t), a = i + s + n, r = i / a, h = s / a, c = n / a, l = this._thresholds[e[0]], u = this._thresholds[e[1]], d = this._thresholds[e[2]], m = this._states.get(l.name), _ = this._states.get(u.name), p = this._states.get(d.name); m.setWeight(r), _.setWeight(h), p.setWeight(c), this._setPhaseLeadState([m, _, p], [l.phaseMatch, u.phaseMatch, d.phaseMatch]) } _setInfluenceClosestPointInTriangles(e) { let t = null, i = Number.POSITIVE_INFINITY, s = -1; this._triangles.forEach(((n, a) => { const r = o.closestPointOnLine(this._vertices[n[0]], this._vertices[n[1]], e), h = o.closestPointOnLine(this._vertices[n[1]], this._vertices[n[2]], e), c = o.closestPointOnLine(this._vertices[n[2]], this._vertices[n[0]], e), l = o.distanceSquared(r, e), u = o.distanceSquared(h, e); let d = c, m = o.distanceSquared(c, e); l < m && (d = r, m = l), u < m && (d = h, m = u), m < i && (i = m, t = [...d], s = a) })), this._setInfluenceTriangle(this._triangles[s], t) } _setInfluenceClosestPointOnLine(e) { const t = o.closestPointOnLine(this._vertices[[0]], this._vertices[[1]], e), i = o.distanceSquared(this._vertices[0], t), s = o.distanceSquared(this._vertices[1], t), n = s / (i + s), a = i / (i + s), r = this._thresholds[0], h = this._thresholds[1], c = this._states.get(r.name), l = this._states.get(h.name); c.setWeight(n), l.setWeight(a), this._setPhaseLeadState([c, l], [r.phaseMatch, h.phaseMatch]) } _setPhaseLeadState(e, t) { let i = 0; e.forEach(((e, s) => { t[s] && e.weight > i && (this._phaseLeadState = e, i = e.weight) })) } }, D = { Override: "Override", Additive: "Additive" }, B = "Override"; class AnimationLayer extends (I.Mixin(P.Mixin())) { constructor(e = {}) { super(e), this.name = void 0 === e.name ? "AnimationLayer" : e.name, this._blendMode = Array.from(Object.values(D)).includes(e.blendMode) ? e.blendMode : B, this._promises = { weight: s.resolve() }, this._weightPaused = !1, this.weight = "number" == typeof e.weight ? e.weight : 1, this._internalWeight = this._weight } get blendMode() { return this._blendMode } set weight(e) { this._weight = o.clamp(e, 0, 1) } get weight() { return this._weight } get weightPending() { return this._promises.weight && this._promises.weight.pending } pause() { return this._paused = !0, this._weightPaused = !0, this.pauseAnimation() || this.weightPending } resume() { this._paused = !1, this._weightPaused = !1; const e = this.weightPending; return this._currentState && this.resumeAnimation() || e } setWeight(e, t = 0, i) { return this.weightPending && this._promises.weight.cancel(), e = o.clamp(e), this._promises.weight = O.interpolateProperty(this, "weight", e, { seconds: t, easingFn: void 0 !== i ? i : this._easingFn }), this._promises.weight } pauseWeight() { return this._weightPaused = !0, this.weightPending } resumeWeight() { return this._weightPaused = !1, this.weightPending } updateInternalWeight(e) { this._internalWeight = this._weight * e, this._currentState && this._currentState.updateInternalWeight(this._internalWeight) } getAnimationBlendNames(e) { const t = this.getState(e); if (void 0 === t) throw new Error(`Cannot get blend names of animation ${e} on layer ${this.name}. No animation exists with this name.`); if (t instanceof V) return t.getStateNames(); throw new Error(`Cannot get blend names of animation ${e} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`) } setAnimationBlendWeight(e, t, i, s = 0, n) { const a = this.getState(e); if (void 0 === a) throw new Error(`Cannot set blend weight of animation ${e} on layer ${this.name}. No animation exists with this name.`); if (a instanceof V) return a.setBlendWeight(t, i, s, n); throw new Error(`Cannot set blend weight of animation ${e} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`) } getAnimationBlendWeight(e, t) { const i = this.getState(e); if (void 0 === i) throw new Error(`Cannot get blend weight of animation ${e} on layer ${this.name}. No animation exists with this name.`); if (i instanceof V) return i.getBlendWeight(t); throw new Error(`Cannot get blend weight of animation ${e} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`) } update(e) { super.update(e), this._paused || this._weightPaused || this._promises.weight.execute(e) } discard() { super.discard(), this.discardStates(), this._promises.weight.cancel(), delete this._promises } } const U = AnimationLayer; const G = class SingleState extends C{ constructor(e = {}) { var t; super(e), this._timeScale = void 0 !== e.timeScale ? e.timeScale : 1, this._promises.timeScale = s.resolve(), this._loopCount = void 0 !== e.loopCount ? e.loopCount : 1 / 0, this._blendMode = (t = e.blendMode, Array.from(Object.values(D)).includes(t) ? t : B) } get normalizedTime() { return 0 } get timeScale() { return this._timeScale } set timeScale(e) { this._timeScale = e } get timeScalePending() { return this._promises.timeScale.pending } setTimeScale(e, t = 0, i) { return this._promises.timeScale.cancel(), this._promises.timeScale = O.interpolateProperty(this, "timeScale", e, { seconds: t, easingFn: i }), this._promises.timeScale } get loopCount() { return this._loopCount } set loopCount(e) { this._loopCount = e } get blendMode() { return this._blendMode } }; class RandomAnimationState extends (I.Mixin(P.Mixin(C))) { constructor(e = {}, t = []) { super(e), this._playInterval = e.playInterval ? e.playInterval : 3, t.forEach((e => { this.addState(e) })) } get playInterval() { return this._playInterval } set playInterval(e) { this._playInterval = e } _resetTimer() { const e = n.getRandomFloat(this._playInterval / 4, 2 * this._playInterval); this._promises.timer = n.wait(e, { onFinish: () => { this.playRandomAnimation(this._playCallbacks.onError) } }) } updateInternalWeight(e) { super.updateInternalWeight(e), this._currentState && this._currentState.updateInternalWeight(this._internalWeight) } playRandomAnimation(e) { this._resetTimer(); const t = this.getStateNames(); this._currentState && t.splice(t.indexOf(this._currentState.name), 1); const i = t[n.getRandomInt(0, t.length)]; this.playAnimation(i, this._transitionTime, this._easingFn, void 0, e, void 0) } play(e, t, i) { return this.playRandomAnimation(t), super.play(e, t, i) } pause() { return super.pause() && this.pauseAnimation() } resume(e, t, i) { return this._currentState && this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, void 0, t, void 0), super.resume(e, t, i) } cancel() { return super.cancel() && this.cancelAnimation() } stop() { return super.stop() && this.stopAnimation() } discard() { super.discard(), this.discardStates() } } const Y = RandomAnimationState, z = { single: G, freeBlend: R, queue: $, randomAnimation: Y, blend1d: W, blend2d: j }; class AnimationFeature extends c{ constructor(e) { super(e), this._layers = [], this._layerMap = {}, this._paused = !1 } _validateIndex(e, t = !0) { if (0 === this._layers.length && t) return; const i = t ? this._layers.length - 1 : this._layers.length; return e < 0 && (e = i + e + 1), e < 0 || e > i ? void 0 : e } _updateInternalWeights() { let e = 1; for (let t = this._layers.length - 1; t >= 0; t--){ const i = this._layers[t]; i.updateInternalWeight(e), i.blendMode === D.Override && i.currentState && (e *= 1 - i.currentState.internalWeight) } } _createSingleState(e) { return new G(e) } _createFreeBlendState(e) { const { blendStateOptions: t = [] } = e, i = []; return t.forEach((t => { i.push(this._createSingleState({ ...t, blendMode: e.blendMode })) })), new R(e, i) } _createQueueState(e) { const { queueOptions: t = [] } = e, i = t.map((t => this._createSingleState({ transitionTime: e.transitionTime, ...t, blendMode: e.blendMode }))); return new $(e, i) } _createBlend1dState(e) { const { blendStateOptions: t = [] } = e, { blendThresholds: i = [] } = e, { blendMatchPhases: s = [] } = e, n = []; return t.forEach((t => { n.push(this._createSingleState({ ...t, blendMode: e.blendMode })) })), new W(e, n, i, s) } _createBlend2dState(e) { const { blendStateOptions: t = [] } = e, { blendThresholds: i = [] } = e, { blendMatchPhases: s = [] } = e, n = []; return t.forEach((t => { n.push(this._createSingleState({ ...t, blendMode: e.blendMode })) })), new j(e, n, i, s) } _createRandomAnimationState(e) { const { subStateOptions: t = [] } = e, i = []; return t.forEach((t => { i.push(this._createSingleState({ ...t, blendMode: e.blendMode })) })), new Y(e, i) } _validateNewAnimation(e, t) { const i = this._layerMap[e]; if (void 0 === i) throw new Error(`Cannot add animation to layer ${e} from host ${this._host.id}. No layer exists with this name.`); const s = n.getUniqueName(t, i.getStateNames()); return s !== t && console.warn(`Animation name ${t} is not unique for layer ${i.name}. Animation will be renamed to ${s}.`), s } get paused() { return this._paused } get layers() { return this._layers.map((e => e.name)) } addLayer(e = "NewLayer", t = {}, i) { const s = this._layers.length; let a = i; void 0 === i || -1 === i ? a = this._layers.length : (a = this._validateIndex(i, !1), void 0 === a && (a = i < 0 ? 0 : this._layers.length, console.warn(`Index ${i} is invalid for host ${this._host.id}. New layer will be added at the closest valid index: ${a}.`))); const r = n.getUniqueName(e, Object.keys(this._layerMap)); e !== r && console.warn(`Layer name ${e} is not unique. New layer will be added with the name ${r}.`); const o = new U({ ...t, name: r }); this._layerMap[r] = o, a === s ? this._layers.push(o) : this._layers.splice(a, 0, o); const h = { name: r, index: a }; return this.emit(this.constructor.EVENTS.addLayer, h), h } removeLayer(e) { const t = this._layerMap[e]; if (void 0 === t) return console.warn(`Did not remove layer ${e} from host ${this._host.id}. No layer exists with this name.`), !1; t.discard(); const i = this._layers.indexOf(t); return this._layers.splice(i, 1), delete this._layerMap[e], this.emit(this.constructor.EVENTS.removeLayer, { name: e, index: i }), !0 } moveLayer(e, t) { const i = this._layerMap[e]; if (void 0 === i) throw new Error(`Cannot move layer ${e} from host ${this._host.id}. No layer exists with this name.`); const s = this._validateIndex(t, !0), n = this._layers.length - 1; if (void 0 === s) throw new Error(`Cannot move layer ${e} from host ${this._host.id} to index ${t}. Index must be in the 0 - ${n} range.`); const a = this._layers.indexOf(i); if (a !== s) return this._layers.splice(a, 1), s === n ? this._layers.push(i) : this._layers.splice(s, 0, i), s } renameLayer(e, t) { const i = this._layerMap[e]; if (void 0 === i) throw new Error(`Cannot rename layer ${e} from host ${this._host.id}. No layer exists with this name.`); const s = n.getUniqueName(t, Object.keys(this._layerMap)); return s !== t && console.warn(`Layer name ${t} is not unique. Layer will be renamed to ${s}.`), delete this._layerMap[e], this._layerMap[s] = i, i.name = s, this.emit(this.constructor.EVENTS.renameLayer, { oldName: e, newName: s }), s } getLayerWeight(e) { const t = this._layerMap[e]; if (void 0 === t) throw new Error(`Cannot get weight on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return t.weight } setLayerWeight(e, t, i, n) { const a = this._layerMap[e]; if (void 0 === a) { const t = `Cannot set weight on layer ${e} from host ${this._host.id}. No layer exists with this name.`; return s.reject(t) } return a.setWeight(t, i, n) } getAnimationBlendNames(e, t) { const i = this._layerMap[e]; if (void 0 === i) throw new Error(`Cannot get blend names on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return i.getAnimationBlendNames(t) } setAnimationBlendWeight(e, t, i, n, a, r) { const o = this._layerMap[e]; if (void 0 === o) { const t = `Cannot set blend weight on layer ${e} from host ${this._host.id}. No layer exists with this name.`; return s.reject(t) } return o.setAnimationBlendWeight(t, i, n, a, r) } getAnimationBlendWeight(e, t, i) { const s = this._layerMap[e]; if (void 0 === s) throw new Error(`Cannot get blend weight on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return s.getAnimationBlendWeight(t, i) } pauseLayerWeight(e) { const t = this._layerMap[e]; if (void 0 === t) throw new Error(`Cannot pause weight interpolation on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return t.pauseWeight() } resumeLayerWeight(e) { const t = this._layerMap[e]; if (void 0 === t) { const t = `Cannot resume weight interpolation on layer ${e} from host ${this._host.id}. No layer exists with this name.`; return s.reject(t) } return t.resumeWeight() } pauseLayer(e) { const t = this._layerMap[e]; if (void 0 === t) throw new Error(`Cannot pause layer ${e} from host ${this._host.id}. No layer exists with this name.`); return t.pause() } resumeLayer(e) { const t = this._layerMap[e]; if (void 0 === t) { const t = `Cannot resume layer ${e} from host ${this._host.id}. No layer exists with this name.`; return s.reject(t) } return t.resume() } getTransitioning(e) { const t = this._layerMap[e]; if (void 0 === t) throw new Error(`Get transitioning on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return t.isTransitioning } getAnimations(e) { const t = this._layerMap[e]; if (void 0 === t) throw new Error(`Get animations on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return t.getStateNames() } getCurrentAnimation(e) { const t = this._layerMap[e]; if (void 0 === t) throw new Error(`Get current animation on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return t.currentAnimation } getPaused(e) { const t = this._layerMap[e]; if (void 0 === t) throw new Error(`Get paused on layer ${e} from host ${this._host.id}. No layer exists with this name.`); return t.currentState && t.currentState.paused } getAnimationType(e, t) { const i = this._layerMap[e]; if (void 0 === i) throw new Error(`Get animation type on layer ${e} from host ${this._host.id}. No layer exists with this name.`); const s = i.getState(t); if (void 0 === s) throw new Error(`Get animation type for animation ${t} on layer ${e} from host ${this._host.id}. No animation exists with this name.`); const { constructor: n } = s; return Object.keys(z).find((e => z[e] === n)) } addAnimation(e, t, i = z.single, s = {}) { if (s.name = this._validateNewAnimation(e, t), !Object.values(z).includes(i)) throw new Error(`Cannot add animation ${t} to layer ${e} on host ${this._host.id}. Invalid animation type.`); const n = this._layerMap[e]; s.blendMode = n.blendMode, s.transitionTime = n.transitionTime; const a = this[`_create${i.name}`](s), r = n.addState(a); return this.emit(this.constructor.EVENTS.addAnimation, { layerName: e, animationName: r }), r } removeAnimation(e, t) { const i = this._layerMap[e]; if (void 0 === i) throw new Error(`Cannot remove animation from layer ${e} from host ${this._host.id}. No layer exists with this name.`); const s = i.removeState(t); return !0 === s && this.emit(this.constructor.EVENTS.removeAnimation, { layerName: e, animationName: t }), s } renameAnimation(e, t, i) { const s = this._layerMap[e]; if (void 0 === s) throw new Error(`Cannot rename animation ${t} on layer ${e} for host ${this._host.id}. No layer exists with this name.`); const n = s.renameState(t, i); return this.emit(this.constructor.EVENTS.renameAnimation, { layerName: e, oldName: t, newName: n }), n } playAnimation(e, t, i, n) { const a = this._layerMap[e]; if (void 0 === a) { const i = `Cannot play animation ${t} on layer ${e} for host ${this._host.id}. No layer exists with this name.`; return s.reject(i) } return this.emit(this.constructor.EVENTS.playAnimation, { layerName: e, animationName: t }), a.playAnimation(t, i, n, (() => { this.emit(this.constructor.EVENTS.stopAnimation, { layerName: e, animationName: t }) }), void 0, (() => { this.emit(this.constructor.EVENTS.interruptAnimation, { layerName: e, animationName: t }) }), (({ name: i, canAdvance: s, isQueueEnd: n }) => { a.currentAnimation === t && this.emit(this.constructor.EVENTS.playNextAnimation, { layerName: e, animationName: t, nextQueuedAnimation: i, canAdvance: s, isQueueEnd: n }) })) } playNextAnimation(e, t, i, n) { const a = this._layerMap[e]; if (void 0 === a) { const t = `Cannot play next animation on layer ${e} for host ${this._host.id}. No layer exists with this name.`; return s.reject(t) } void 0 === t && (t = a.currentAnimation); const r = a.getState(a.currentAnimation); if (null === r) { const i = `Cannot play next animation on layer ${e} for host ${this._host.id}. No animation exists with name ${t}.`; return s.reject(i) } if ("queue" !== this.getAnimationType(e, t)) { const i = `Cannot play next animation on layer ${e} for host ${this._host.id}. ${t} is not a queue state.`; return s.reject(i) } const o = ({ name: i, canAdvance: s, isQueueEnd: n }) => { a.currentAnimation === t && this.emit(this.constructor.EVENTS.playNextAnimation, { layerName: e, animationName: t, nextQueuedAnimation: i, canAdvance: s, isQueueEnd: n }) }; return null === a.currentAnimation && a.resumeAnimation(r.name, i, n, void 0, void 0, void 0, o), r.next(o, !0) } pauseAnimation(e) { const t = this._layerMap[e]; if (void 0 === t) return console.warn(`Did not pause animation on layer ${e} for host ${this._host.id}. No layer exists with this name.`), !1; const i = t.pauseAnimation(); if (i) { const i = t.currentAnimation; this.emit(this.constructor.EVENTS.pauseAnimation, { layerName: e, animationName: i }) } return i } resumeAnimation(e, t, i, n) { const a = this._layerMap[e]; if (void 0 === a) { const i = `Cannot resume animation ${t} on layer ${e} for host ${this._host.id}. No layer exists with this name.`; return s.reject(i) } return this.emit(this.constructor.EVENTS.resumeAnimation, { layerName: e, animationName: t }), a.resumeAnimation(t, i, n, (() => { this.emit(this.constructor.EVENTS.stopAnimation, { layerName: e, animationName: t }) }), void 0, (() => { this.emit(this.constructor.EVENTS.interruptAnimation, { layerName: e, animationName: t }) }), (({ name: i, canAdvance: s, isQueueEnd: n }) => { a.currentAnimation === t && this.emit(this.constructor.EVENTS.playNextAnimation, { layerName: e, animationName: t, nextQueuedAnimation: i, canAdvance: s, isQueueEnd: n }) })) } stopAnimation(e) { const t = this._layerMap[e]; return void 0 === t ? (console.warn(`Did not stop animation on layer ${e} for host ${this._host.id}. No layer exists with this name.`), !1) : t.stopAnimation() } pause() { this._paused = !0; let e = !1; return this._layers.forEach((t => { t.pause() && (e = !0) })), e } resume() { this._paused = !1; let e = !1; return this._layers.forEach((t => { t.resume() && (e = !0) })), e } installApi() { const e = super.installApi(); Object.defineProperties(e, { paused: { get: () => this.paused }, layers: { get: () => this.layers } }), Object.assign(e, { addLayer: this.addLayer.bind(this), removeLayer: this.removeLayer.bind(this), moveLayer: this.moveLayer.bind(this), renameLayer: this.renameLayer.bind(this), getLayerWeight: this.getLayerWeight.bind(this), setLayerWeight: this.setLayerWeight.bind(this), pauseLayerWeight: this.pauseLayerWeight.bind(this), resumeLayerWeight: this.resumeLayerWeight.bind(this), pauseLayer: this.pauseLayer.bind(this), resumeLayer: this.resumeLayer.bind(this), getTransitioning: this.getTransitioning.bind(this), getAnimations: this.getAnimations.bind(this), getCurrentAnimation: this.getCurrentAnimation.bind(this), getPaused: this.getPaused.bind(this), getAnimationType: this.getAnimationType.bind(this), addAnimation: this.addAnimation.bind(this), removeAnimation: this.removeAnimation.bind(this), renameAnimation: this.renameAnimation.bind(this), getAnimationBlendNames: this.getAnimationBlendNames.bind(this), getAnimationBlendWeight: this.getAnimationBlendWeight.bind(this), setAnimationBlendWeight: this.setAnimationBlendWeight.bind(this), playAnimation: this.playAnimation.bind(this), playNextAnimation: this.playNextAnimation.bind(this), pauseAnimation: this.pauseAnimation.bind(this), resumeAnimation: this.resumeAnimation.bind(this), stopAnimation: this.stopAnimation.bind(this), pause: this.pause.bind(this), resume: this.resume.bind(this) }) } update(e) { this._layers.length && (this._paused && (e = 0), this._updateInternalWeights(), this._layers.forEach((t => { t.update(e) })), super.update(e)) } discard() { this._layers.forEach((e => { e.discard() })), delete this._layers, delete this._layerMap, super.discard() } } Object.defineProperty(AnimationFeature, "EVENTS", { value: { ...Object.getPrototypeOf(c).EVENTS, addLayer: "onAddLayerEvent", removeLayer: "onRemoveLayerEvent", renameLayer: "onRenameLayerEvent", addAnimation: "onAddAnimationEvent", removeAnimation: "onRemovedAnimationEvent", renameAnimation: "onRenameAnimationEvent", playAnimation: "onPlayEvent", playNextAnimation: "onNextEvent", pauseAnimation: "onPauseEvent", resumeAnimation: "onResumeEvent", interruptAnimation: "onInterruptEvent", stopAnimation: "onStopEvent" } }); const H = AnimationFeature, q = { PositiveX: [1, 0, 0], NegativeX: [-1, 0, 0], PositiveY: [0, 1, 0], NegativeY: [0, -1, 0], PositiveZ: [0, 0, 1], NegativeZ: [0, 0, -1] }, X = 0, Q = 1, J = 2, Z = 3, K = [[0, 0, 0], [-.032, 0, 0], [.032, 0, 0], [0, -.064, 0]], ee = { default: [.8, 1.75], postMacro: [.6, 1.3125] }, te = { default: [5, 8], mouthTarget: [.2, .75], eyeTarget: [1.5, 4] }; class PointOfInterestFeature extends (c.mix(N.Mixin, w.Mixin)) { constructor(e, { target: t, lookTracker: i, scene: s } = {}, { blendTime: n = .1, easingFn: a = d.InOut, layers: r = [] } = {}, { blendTime: o = .075, easingFn: h = d.InOut, layers: c = [] } = {}) { if (super(e), !this.constructor._validateTransformObject(i)) throw new Error(`Cannot initialize PointOfInterestFeature on host ${this._host.id}. LookTracker must be defined as a valid transformation object.`); this._lookTracker = i, this._scene = s, this._target = t || null, this._prevTargetPos = [0, 0, 0], this._isTargetMoving = !1, this._lookLayers = this._lookLayers || {}, this._trackingConfigs = this._trackingConfigs || [], this._blinkLayers = this._blinkLayers || {}, r.forEach((({ name: e, animation: t, maxSpeed: i, reference: s, forwardAxis: r, hasSaccade: o, blendTime: h, easingFn: c }) => { this.registerLookLayer(e, { animation: t, maxSpeed: i, reference: s, forwardAxis: r, hasSaccade: o, blendTime: void 0 !== h ? h : n, easingFn: void 0 !== c ? c : a }) })), c.forEach((({ name: e, animation: t, blendTime: i, easingFn: s }) => { this.registerBlinkLayer(e, { animation: t, blendTime: void 0 !== i ? i : o, easingFn: void 0 !== s ? s : h }) })) } get target() { return this._target } set target(e) { this._target = e || null } static _getWorldPosition(e) { return [0, 0, 0] } static _getWorldMatrix(e) { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } static _getObjectDirection(e, t = q.PositiveZ) { const i = o.getRotationMatrix(this._getWorldMatrix(e)); return o.rotateVector(t, i) } static _sphericalToBlendValue(e, t) { return { h: o.toDegrees(t), v: o.toDegrees(e) - 90 } } _onLayerAdded({ name: e }) { this._lookLayers = this._lookLayers || {}, this._blinkLayers = this._blinkLayers || {}, super._onLayerAdded({ name: e }), void 0 !== this._lookLayers[e] && this._registerLookAnimation(e, this._lookLayers[e]) } _onAnimationAdded({ layerName: e, animationName: t }) { this._lookLayers = this._lookLayers || {}, this._blinkLayers = this._blinkLayers || {}, super._onAnimationAdded({ layerName: e }), this._lookLayers[e] === t && this._registerLookAnimation(e, t) } _registerLookAnimation(e, t) { this._managedLayers[e].animations[t].isActive && z[this._host.AnimationFeature.getAnimationType(e, t)] !== z.blend2d && (console.warn(`Cannot register Point of Interest look animation ${t} on layer ${e} for host ${this._host.id}. Look animations must be of type 'blend2d'.`), this._managedLayers[e].animations[t].isActive = !1) } static _validateTransformObject(e) { return e instanceof Object } _addTrackingConfig(e) { const t = this._trackingConfigs.find((t => t.reference === e.reference && t.forwardAxis === e.forwardAxis)); return t || (e.angles = { h: 0, v: 0 }, e.prevAngles = { h: 0, v: 0 }, this._trackingConfigs.push(e), e) } _getTargetDistance() { const e = this.constructor._getWorldPosition(this._lookTracker), t = this.constructor._getWorldPosition(this._target), i = [t[0] - e[0], t[1] - e[1], t[2] - e[2]]; return o.getVectorMagnitude(i) } _resetLookAngles() { this._trackingConfigs.forEach((({ angles: e }) => { e.h = 0, e.v = 0 })) } _setLookAngles() { const e = this.constructor._getWorldPosition(this._target), t = this.constructor._getWorldPosition(this._lookTracker); this._isTargetMoving = o.getVectorMagnitude([e[0] - this._prevTargetPos[0], e[1] - this._prevTargetPos[1], e[2] - this._prevTargetPos[2]]) > 0, Object.assign(this._prevTargetPos, e); const i = o.cartesianToSpherical(e[0] - t[0], e[1] - t[1], e[2] - t[2]), s = this.constructor._sphericalToBlendValue(i[1], i[2]); this._trackingConfigs.forEach((({ reference: e, forwardAxis: t, angles: i }) => { const n = this.constructor._getObjectDirection(e, t), a = o.cartesianToSpherical(...n), r = this.constructor._sphericalToBlendValue(a[1], a[2]); i.h = s.h - r.h, i.v = s.v - r.v })) } _getFaceTargetAngles(e) { if (0 === e) return { h: 0, v: 0 }; const t = this._getTargetDistance(this._lookTracker), i = [...K[e]]; i[2] = t; const s = o.cartesianToSpherical(...i), n = this.constructor._sphericalToBlendValue(s[1], s[2]); return n.h = o.clamp(n.h, -35, 35), n.v = o.clamp(n.v, -25, 30), n } _updateLayerSpeed(e, t, i) { const s = this._managedLayers[e]; s.maxHSpeed = 473 * (1 - Math.exp(-t / 7.8)), s.maxVSpeed = 473 * (1 - Math.exp(-i / 7.8)); const n = .00235; s.hDuration = .025 + n * t, s.vDuration = .025 + n * i } _setMicroSaccade(e) { const t = this._managedLayers[e], { microSaccade: i } = t; this._target ? (i.h = n.getRandomFloat(.01, .15), i.v = n.getRandomFloat(.01, .15)) : (i.h = n.getRandomFloat(.01, .3), i.v = n.getRandomFloat(.01, .3)), this._updateLayerSpeed(e, i.h, i.v), this._initializeMicroTimer(e, ...ee.default) } _setMacroSaccade(e) { const t = this._managedLayers[e], { macroSaccade: i } = t; let s; if (this._target) { switch (t.saccadeTarget) { case 1: s = te.eyeTarget, t.saccadeTarget = Math.random() < .75 ? J : Z; break; case 2: s = te.eyeTarget, t.saccadeTarget = Math.random() < .75 ? Q : Z; break; case 3: s = te.mouthTarget, t.saccadeTarget = Math.random() < .5 ? Q : J; break; default: s = te.eyeTarget, t.saccadeTarget = Math.random() < .5 ? Q : J }const { h: e, v: n } = this._getFaceTargetAngles(t.saccadeTarget); i.h = e, i.v = n } else { s = te.default; const e = n.getRandomFloat(.143, .286), t = n.getRandomFloat(-e, e); i.h = 35 * t; const a = n.getRandomFloat(.093, .186), r = n.getRandomFloat(-a, a); i.v = r > 0 ? 25 * r : 30 * r } this._updateLayerSpeed(e, i.h, i.v), this._initializeMicroTimer(e, ...ee.postMacro), this._initializeMacroTimer(e, ...s) } _initializeMicroTimer(e, t, i) { const s = this._managedLayers[e], a = n.getRandomFloat(t, i); s.microSaccadeTimer && s.microSaccadeTimer.cancel(), s.microSaccadeTimer = n.wait(a, { onFinish: () => { this._setMicroSaccade(e) } }) } _initializeMacroTimer(e, t, i) { const s = this._managedLayers[e], a = n.getRandomFloat(t, i); s.macroSaccadeTimer && s.macroSaccadeTimer.cancel(), s.macroSaccadeTimer = n.wait(a, { onFinish: () => { this._setMacroSaccade(e) } }) } setTarget(e) { this.target = e } setTargetByName(e) { if (e || (this._target = null), !this._scene) throw new Error(`Cannot set PointOfInterestFeature target using name ${e} on host ${this._host.id}. Scene must be defined.`) } setTargetById(e) { if (e || (this._target = null), !this._scene) throw new Error(`Cannot set PointOfInterestFeature target using id ${e} on host ${this._host.id}. Scene must be defined.`) } registerLookLayer(e, { animation: t = "look", maxSpeed: i = 25, reference: s, forwardAxis: n = "PositiveZ", hasSaccade: a = !1, blendTime: r = PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime, easingFn: o } = {}) { if (s = s || this._host.owner, !this.constructor._validateTransformObject(s)) throw new Error(`Cannot initialize register look layer ${e} for PointOfInterestFeature on host ${this._host.id}. Reference must be defined as a valid transformation object.`); n = void 0 !== q[n] ? q[n] : q.PositiveZ; const h = this._addTrackingConfig({ reference: s, forwardAxis: n }); if (this.registerLayer(e, { trackingConfig: h, maxSpeed: i, maxHSpeed: void 0, maxVSpeed: void 0, hDuration: void 0, vDuration: void 0, hVelocity: [0, 0], vVelocity: [0, 0], hasSaccade: a, blendTime: r, easingFn: o, microSaccade: { h: 0, v: 0 }, macroSaccade: { h: 0, v: 0 }, saccadeTarget: X, animations: { [t]: {} } }), this._lookLayers[e] = t, this._registerLookAnimation(e, t), a) { const t = this._target ? te.eyeTarget : te.default; this._initializeMicroTimer(e, ...ee.default), this._initializeMacroTimer(e, ...t) } } registerBlinkLayer(e, { animation: t = "blink", blendTime: i = PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime, easingFn: s } = {}) { this.registerLayer(e, { blendTime: i, easingFn: s, animations: { [t]: {} } }), this._blinkLayers[e] = t } update(e) { super.update(e), this._target ? this._setLookAngles() : this._resetLookAngles(); const t = Math.min(e, 33.333333333333336) / 1e3; let i = !1; Object.entries(this._lookLayers).forEach((([s, n]) => { const a = this._managedLayers[s]; if (a.isActive && a.hasSaccade && (a.microSaccadeTimer.execute(e), a.macroSaccadeTimer.execute(e)), a.animations[n].isActive) { const e = this._host.AnimationFeature.getAnimationBlendWeight(s, n, "X"), r = this._host.AnimationFeature.getAnimationBlendWeight(s, n, "Y"); let h = a.trackingConfig.angles.h, c = a.trackingConfig.angles.v; if (this._isTargetMoving && !i) { const e = a.trackingConfig.prevAngles.h, t = a.trackingConfig.prevAngles.v; o.toDegrees(o.getAngleBetween([e, t], [h, c])) >= 35 && (i = !0) } a.trackingConfig.prevAngles.h = h, a.trackingConfig.prevAngles.v = c, a.hasSaccade && (o.dampValue(0, a.macroSaccade.h + a.macroSaccade.h, a.hVelocity, a.hDuration, a.maxHSpeed), h += a.hVelocity[0], o.dampValue(0, a.macroSaccade.v + a.macroSaccade.v, a.vVelocity, a.vDuration, a.maxVSpeed), c += a.vVelocity[0]); const l = o.clamp(t * a.maxSpeed, 0, 1); h = o.lerp(e, h, l), c = o.lerp(r, c, l), this._host.AnimationFeature.setAnimationBlendWeight(s, n, "X", h), this._host.AnimationFeature.setAnimationBlendWeight(s, n, "Y", c) } })), i && this._isTargetMoving && Object.entries(this._blinkLayers).forEach((([e, t]) => { this._managedLayers[e].animations[t].isActive && this._host.AnimationFeature.playAnimation(e, t) })) } installApi() { const e = super.installApi(); return Object.defineProperties(e, { target: { get: () => this.target, set: e => { this.target = e } } }), Object.assign(e, { registerLookLayer: this.registerLookLayer.bind(this), registerBlinkLayer: this.registerBlinkLayer.bind(this), setTarget: this.setTarget.bind(this), setTargetByName: this.setTargetByName.bind(this), setTargetById: this.setTargetById.bind(this) }), e } } const ie = PointOfInterestFeature, se = { AnimationFeature: H, AnimationLayer: U, SingleState: G, TransitionState: k, FreeBlendState: R, QueueState: $, RandomAnimationState: Y, Blend1dState: W, Blend2dState: j, AnimationUtils: O, Easing: { Linear: u, Quadratic: d, Cubic: m, Quartic: _, Quintic: p, Sinusoidal: g, Exponential: y, Circular: f, Elastic: v, Back: E, Bounce: A }, LayerBlendModes: D, DefaultLayerBlendMode: B, AnimationTypes: z }; class TextToSpeechUtils{ static autoGenerateSSMLMarks(e, t, i = []) { if ("object" != typeof t || null === t) throw new Error(`Cannot generate SSML marks for text "${e}" because map is not an object.`); const s = this._processInputMap(t), n = ["<speak>", "</speak>"], a = /<mark name=(?:"|')(.*?)(?:"|')\/>/, r = /<[^>]*>/g, o = []; let h = r.exec(e); for (; null !== h;)o.push({ start: h.index, end: h.index + h[0].length, text: h[0] }), h = r.exec(e); const c = []; let l, u = 0, d = []; o.forEach((t => { const i = e.slice(u, t.start); if ("" !== i && (c.push(this._insertMarks(i, s, d)), d = []), l = a.exec(t.text), null !== l) { const e = l[1]; d.push(e) } else n.includes(t.text) || c.push(t.text); u = t.end })), c.push(this._insertMarks(e.slice(u), s, d)); let m = c.join(""); return i && i.length > 0 && (m = this.addMarksToUnmarkedSentences(m, i)), TextToSpeechUtils.validateText(m) } static addMarksToUnmarkedSentences(e, t) { if (!t || 0 === t.length) return e; const i = /<mark name=(?:"|')(.*?)(?:"|')\/>/g, s = /<[^>]*>/g, n = []; let a = i.exec(e); for (; null !== a;)n.push(a.index), a = i.exec(e); const r = []; let o = s.exec(e); for (; null !== o;)r.push({ start: o.index, end: o.index + o[0].length, text: o[0] }), o = s.exec(e); let h = e.slice(); r.forEach((e => { const t = new Array(e.text.length + 1).join(" "); h = [h.slice(0, e.start), t, h.slice(e.end)].join("") })); const c = this._getSentenceEnds(h); let l = 0; const u = c.filter((e => { const t = -1 !== n.findIndex((t => l <= t && e > t)); return l = e, !t })); return this._insertRandomMarksAt(e, u, t) } static validateText(e) { return e = e ? e.replace(/(^\s*<\s*speak\s*)>\s*|(^\s*)/, "<speak>").replace(/(\s*<\s*\/\s*speak\s*>\s*$|\s*$)/, "</speak>") : "<speak></speak>" } static _insertRandomMarksAt(e, t = [], i = []) { if (!i || 0 === i.length || !t || 0 === t.length) return e; let s = 0; return t.forEach((t => { const a = `<mark name='${i[n.getRandomInt(0, i.length)]}'/>`; e = [e.slice(0, t + s), a, e.slice(t + s)].join(""), s += a.length })), e } static _getSentenceEnds(e) { const t = /[^.!?]+[.!?]+/g, i = /[.!?]+/; let s = t.exec(e); const n = []; for (; null !== s;){ const a = i.exec(s[0]); n.push(s.index + s[0].length - a[0].length), s = t.exec(e) } return n } static _insertMarks(e, t, i) { if ("" === e) return e; let s, n = !0; const a = e.match(/\w+|\s+|[^\s\w]+/g).map((e => { if (s = e.toLowerCase(), t.has(s)) { return `${t.get(s).map((e => n ? (n = !1, i.includes(e) ? "" : `<mark name='${e}'/>`) : `<mark name='${e}'/>`)).join("")}${e}` } return n = !1, e })); return `${i.map((e => `<mark name='${e}'/>`)).join("")}${a.join("")}` } static _processInputMap(e) { const t = new Map; let i = []; return Object.entries(e).forEach((([s, n]) => { if (!Array.isArray(n)) throw new Error(`Cannot generate SSML marks from map "${e}" because value for key '${s}' is not an array.`); n.forEach((e => { const n = e.toLowerCase(); i = t.get(n), void 0 === i || i.includes(s) ? t.set(n, [s]) : t.set(n, [...i, s]) })) })), t } } const ne = TextToSpeechUtils; const ae = class AbstractSpeech{ constructor(e, t, i = []) { this._speaker = e, this._text = t, this._speechmarks = i, this._speechmarkOffset = 0, this._reset() } _reset(e = 0) { this._startTime = e, this._localTime = 0, this._pauseTime = 0, this._playing = !1, this._markIter = this._speechmarks.values(); const { value: t, done: i } = this._markIter.next(); this._currentMark = t, this._endTime = this._speechmarks.length ? this._speechmarks[this._speechmarks.length - 1].time : 0, this._done = i, this._promise = null } _createPromise(e, t, i) { return this._promise = new s(void 0, (t => { this._playing = !1, this._speaker.emit(this._speaker.constructor.EVENTS.stop, this), this._speaker.constructor.emit(this._speaker.constructor.EVENTS.stop, this), "function" == typeof e && e(t) }), (e => { this._playing = !1, this._speaker.emit(this._speaker.constructor.EVENTS.stop, this), this._speaker.constructor.emit(this._speaker.constructor.EVENTS.stop, this), console.error(`${this.constructor.name} encountered an unexpected error: ${e}`), "function" == typeof t && t(e) }), (e => { this._playing = !1, this._speaker.emit(this._speaker.constructor.EVENTS.interrupt, this), this._speaker.constructor.emit(this._speaker.constructor.EVENTS.interrupt, this), "function" == typeof i && i(e) })), this._promise } _checkFinished() { return this._done && this._localTime >= this._endTime } get playing() { return this._playing } get text() { return this._text } get speechmarks() { return [...this._speechmarks] } get speechmarkOffset() { return this._speechmarkOffset / 1e3 } set speechmarkOffset(e) { this._speechmarkOffset = 1e3 * e } update(e) { if (this._playing) { if (this._localTime = e - this._startTime, !this._done) for (; !this._done && this._currentMark.time + this._speechmarkOffset <= this._localTime;){ this._speaker.emit(this._speaker.constructor.EVENTS[this._currentMark.type], { speech: this, mark: this._currentMark }); const { value: e, done: t } = this._markIter.next(); this._currentMark = e, this._done = t } this._checkFinished() && (this.stop(), this._reset()) } } play(e, t, i, s) { return this._reset(e), this._playing = !0, this._speaker.emit(this._speaker.constructor.EVENTS.play, this), this._speaker.constructor.emit(this._speaker.constructor.EVENTS.play, this), this._createPromise(t, i, s) } pause(e) { this._playing = !1, this._pauseTime = e, this._speaker.emit(this._speaker.constructor.EVENTS.pause, this), this._speaker.constructor.emit(this._speaker.constructor.EVENTS.pause, this) } resume(e, t, i, s) { return this._promise || (this._reset(e), this._createPromise(t, i, s)), this._playing = !0, this._startTime += e - this._pauseTime, this._speaker.emit(this._speaker.constructor.EVENTS.resume, this), this._speaker.constructor.emit(this._speaker.constructor.EVENTS.resume, this), this._promise } cancel() { this._promise && (this._promise.cancel(), this._promise = null), this._playing = !1 } stop() { this._promise && (this._promise.resolve(), this._promise = null), this._playing = !1 } }; const re = class Speech extends ae{ constructor(e, t, i = [], s) { super(e, t, i), this._audio = s.audio, this._audio.onended = () => { this._audioFinished = !0 }, this._audioFinished = !0 } _checkFinished() { return this._audioFinished && super._checkFinished() } get audio() { return this._audio } get volume() { return this._audio.volume } set volume(e) { this._audio.volume = e } _playAudio() { this._speechmarkOffset < 0 ? (this._audio.currentTime = this._speechmarkOffset, setTimeout((() => { this._playing && (this._audio.currentTime = (this._localTime + this._speechmarkOffset) / 1e3, this._audio.play()) }), -this._speechmarkOffset)) : (this._audio.currentTime = 0, this._audio.play()) } _pauseAudio() { this._audio.play().then((() => { this._playing || this._audio.pause() })) } play(e, t, i, s) { return this._audioFinished = !1, this._playAudio(), super.play(e, t, i, s) } pause(e) { this._pauseAudio(), super.pause(e) } resume(e, t, i, s) { return this._audioFinished = !1, this._audio.play(), super.resume(e, t, i, s) } cancel() { this._pauseAudio(), super.cancel() } stop() { this._pauseAudio(), this._audio.currentTime = 0, super.stop() } }, oe = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i, he = e => { if ("string" != typeof e) throw new TypeError("Invalid argument expected string"); const t = e.match(oe); if (!t) throw new Error(`Invalid argument not valid semver ('${e}' received)`); return t.shift(), t }, ce = e => "*" === e || "x" === e || "X" === e, le = e => { const t = parseInt(e, 10); return isNaN(t) ? e : t }, ue = (e, t) => { if (ce(e) || ce(t)) return 0; const [i, s] = ((e, t) => typeof e != typeof t ? [String(e), String(t)] : [e, t])(le(e), le(t)); return i > s ? 1 : i < s ? -1 : 0 }, de = (e, t) => { for (let i = 0; i < Math.max(e.length, t.length); i++){ const s = ue(e[i] || "0", t[i] || "0"); if (0 !== s) return s } return 0 }, me = (e, t) => { const i = he(e), s = he(t), n = i.pop(), a = s.pop(), r = de(i, s); return 0 !== r ? r : n && a ? de(n.split("."), a.split(".")) : n || a ? n ? -1 : 1 : 0 }, _e = ["standard", "neural"], pe = ["mp3", "ogg_vorbis", "pcm"], ge = ["sentence", "ssml", "viseme", "word"], ye = { mp3: { rates: ["8000", "16000", "22050", "24000"], defaults: { standard: "2050", neural: "2400" } }, pcm: { rates: ["8000", "16000"], defaults: { standard: "1600", neural: "1600" } } }; let fe; ye.ogg_vorbis = ye.mp3; class AbstractTextToSpeechFeature extends c{ constructor(e, t = { voice: void 0, engine: void 0, language: void 0, audioFormat: "mp3", sampleRate: void 0, speechmarkOffset: 0, minEndMarkDuration: .05, volume: 1, isGlobal: !1 }) { super(e), this._speechCache = {}, this._currentSpeech = null, this._currentPromise = null, this._isValidated = !1, this.speechmarkOffset = Number.isNaN(Number(t.speechmarkOffset)) ? 0 : Number(t.speechmarkOffset), this.minEndMarkDuration = Number.isNaN(Number(t.minEndMarkDuration)) ? 0 : Number(t.minEndMarkDuration), this.volume = Number.isNaN(Number(t.volume)) ? 1 : Number(t.volume), this._isGlobal = t.isGlobal || !1, this._promises = { volume: s.resolve() }, this._volumePaused = !1, this._voice = t.voice || this.constructor.POLLY_DEFAULTS.VoiceId, this._language = t.language || this.constructor.POLLY_DEFAULTS.LanguageName, this._engine = _e.includes(t.engine) ? t.engine : this.constructor.POLLY_DEFAULTS.Engine, this._audioFormat = pe.includes(t.audioFormat) ? t.audioFormat : this.constructor.POLLY_DEFAULTS.OutputFormat, this._sampleRate = ye[this._audioFormat].rates.includes(t.sampleRate) ? t.sampleRate : this.constructor.POLLY_DEFAULTS.SampleRate } static initializeService(e, t, i) { if (void 0 === e || void 0 === t || void 0 === i) throw new Error("Cannot initialize TextToSpeech feature. All arguments must be defined."); e.config && (e.config.customUserAgent = n.addCoreUserAgentComponent(e.config.customUserAgent), e.config.customUserAgent = n.addStringOnlyOnce(e.config.customUserAgent, this.prototype.getEngineUserAgentString())), t.service && t.service.config && (t.service.config.customUserAgent = n.addCoreUserAgentComponent(t.service.config.customUserAgent), t.service.config.customUserAgent = n.addStringOnlyOnce(t.service.config.customUserAgent, this.prototype.getEngineUserAgentString())), this._isReady = !1, this.SERVICES.polly = e, this.SERVICES.presigner = t, fe = i; const s = this.POLLY_VOICES; s.length = 0; const a = this.POLLY_LANGUAGES; Object.keys(a).forEach((e => { delete a[e] })); const r = this.POLLY_LANGUAGE_CODES; Object.keys(r).forEach((e => { delete r[e] })); const o = this.POLLY_MIN_NEURAL_VERSION; return this.SERVICES.polly.describeVoices().promise().then((e => { const t = {}; e.Voices.forEach((e => { (e.SupportedEngines.includes("standard") || me(i, o) >= 0) && s.push(e), s.forEach((e => { a[e.LanguageName] = e.LanguageCode, t[e.LanguageCode] = e.LanguageName })) })), Object.entries(a).forEach((([e, t]) => { r[t] = e })), this._isReady = !0, this.emit(this.EVENTS.ready) })) } static get isReady() { return this._isReady } get currentSpeech() { return this._currentSpeech ? this._currentSpeech.text : null } get speechmarkOffset() { return this._speechmarkOffset } set speechmarkOffset(e) { this._speechmarkOffset = e, this._currentSpeech && (this._currentSpeech.speechmarkOffset = e) } get minEndMarkDuration() { return this._minEndMarkDuration / 1e3 } set minEndMarkDuration(e) { this._minEndMarkDuration = 1e3 * e } _validateEngine(e) { return (void 0 === e || me(this.constructor.AWS_VERSION, this.constructor.POLLY_MIN_NEURAL_VERSION) < 0) && (e = this.constructor.POLLY_DEFAULTS.Engine), e } _validateFormat(e) { return void 0 !== e && pe.includes(e) || (e = this.constructor.POLLY_DEFAULTS.OutputFormat), e } _validateRate(e) { return void 0 !== e && ye[this._audioFormat].rates.includes(e) || (e = ye[this._audioFormat].defaults[this._engine]), e } _validateVoice(e) { const t = this.constructor.POLLY_VOICES.find((t => t.Id === e)); return void 0 !== t && t.SupportedEngines.includes(this._engine) || (e = this.constructor.POLLY_DEFAULTS.VoiceId), e } _validateLanguage(e) { const t = this.constructor.POLLY_VOICES.find((e => e.Id === this._voice)), i = this.constructor.POLLY_LANGUAGES[e], s = [t.LanguageCode]; return t.AdditionalLanguageCodes && s.push(...t.AdditionalLanguageCodes), s.includes(i) || (e = this.constructor.POLLY_LANGUAGE_CODES[t.LanguageCode]), e } _validate() { this._engine = this._validateEngine(this._engine), this._audioFormat = this._validateFormat(this._audioFormat), this._sampleRate = this._validateRate(this._sampleRate), this._voice = this._validateVoice(this._voice), this._language = this._validateLanguage(this._language), this._isValidated = !0 } _getConfig() { return this.constructor.isReady && !this._isValidated && this._validate(), { Engine: this._engine, OutputFormat: this._audioFormat, SampleRate: this._sampleRate, VoiceId: this._voice, LanguageCode: this.constructor.POLLY_LANGUAGES[this._language] } } _updateConfig(e, t = []) { const i = this._getConfig(); if (!e) return i; this._isValidated = !1; const s = JSON.stringify(i); e.Engine && (this._engine = e.Engine), e.audioFormat && (this._audioFormat = e.audioFormat), e.SampleRate && (this._sampleRate = e.SampleRate), e.VoiceId && (this._voice = e.VoiceId), e.Language && (this._language = e.Language); const n = this._getConfig(), a = JSON.stringify(n); return s === a ? (this._isValidated = !0, n) : (Object.entries(this._speechCache).forEach((([e, i]) => { if (t.includes(e)) return; JSON.stringify(i.config) !== a && this._updateSpeech(e, n) })), n) } _updateSpeech(e, t, i = !1) { const s = this._speechCache[e] || {}; if (!i && void 0 !== t && s.config && JSON.stringify(t) === JSON.stringify(s.config)) return s; const n = { ...t, Text: e, TextType: "ssml" }, a = { ...n, OutputFormat: "json", SpeechMarkTypes: ge }; return s.config = t, s.promise = Promise.all([this._synthesizeSpeechmarks(a), this._synthesizeAudio(n)]).then((t => this._createSpeech(e, ...t))), this._speechCache[e] = s, s } _createSpeech(e, t, i) { return new ae(this, e, t, i) } _synthesizeAudio(e) { return new s(((t, i) => { this.constructor.SERVICES.presigner.getSynthesizeSpeechUrl(e, (function (e, s) { e ? i(e) : t({ url: s }) })) })) } _synthesizeSpeechmarks(e) { return this.constructor.SERVICES.polly.synthesizeSpeech(e).promise().then((e => { const t = JSON.stringify(e.AudioStream), i = JSON.parse(t).data.map((e => String.fromCharCode(e))).join(""), s = { sentence: [], word: [], viseme: [], ssml: [] }, n = { sentence: null, word: null, viseme: null, ssml: null }, a = [...i.matchAll(/\{.*?\}(?=\n|$)/gm)].map((e => { const t = JSON.parse(e[0]), i = s[t.type].length; if (i > 0) { const e = s[t.type][i - 1]; e.duration = t.time - e.time } return s[t.type].push(t), n[t.type] = t, t })), r = []; n.sentence && r.push(n.sentence.time), n.word && r.push(n.word.time), n.viseme && r.push(n.viseme.time), n.ssml && r.push(n.ssml.time); const o = Math.max(...r); return n.sentence && (n.sentence.duration = Math.max(this._minEndMarkDuration, o - n.sentence.time)), n.word && (n.word.duration = Math.max(this._minEndMarkDuration, o - n.word.time)), n.viseme && (n.viseme.duration = Math.max(this._minEndMarkDuration, o - n.viseme.time)), n.ssml && (n.ssml.duration = Math.max(this._minEndMarkDuration, o - n.ssml.time)), a })) } _getSpeech(e, t) { if (!this.constructor.isReady) { const e = "AWS services have not been initialized."; return s.reject(e) } if (!e) { const e = "Cannot play a speech with no text."; return s.reject(e) } return e = ne.validateText(e), t = this._updateConfig(t, e), this._updateSpeech(e, t).promise } installApi() { const e = super.installApi(); return Object.assign(e, { play: this.play.bind(this), pause: this.pause.bind(this), resume: this.resume.bind(this), stop: this.stop.bind(this), getVolume: this.getVolume.bind(this), setVolume: this.setVolume.bind(this), pauseVolume: this.pauseVolume.bind(this), resumeVolume: this.resumeVolume.bind(this) }), Object.defineProperties(e, { speechmarkOffset: { get: () => this.speechmarkOffset, set: e => { this.speechmarkOffset = e } } }), e } set volume(e) { this._volume = o.clamp(e) } get volume() { return this._volume } get volumePending() { return this._promises.volume && this._promises.volume.pending } getVolume() { return this.volume } setVolume(e, t = 0, i) { return this.volumePending && this._promises.volume.cancel(), e = o.clamp(e), this._promises.volume = O.interpolateProperty(this, "volume", e, { seconds: t, easingFn: i }), this._promises.volume } pauseVolume() { return this._volumePaused = !0, this.volumePending } resumeVolume() { return this._volumePaused = !1, this.volumePending } update(e) { this._volumePaused || this._promises.volume.execute(e), this._currentSpeech && this._currentSpeech.playing && (this._currentSpeech.volume = this._volume, this._currentSpeech.update(this._host.now), super.update(e)) } _setCurrentSpeech(e) { e.speechmarkOffset = this._speechmarkOffset, this._currentSpeech = e } _startSpeech(e, t, i = "play") { void 0 === e && "resume" === i && this._currentSpeech && (e = this._currentSpeech.text); const n = this._currentPromise || { play: new s(void 0, (() => { n.speech.cancel() }), (() => { n.speech.cancel() }), (() => { n.speech.cancel() })), speech: new s }; return this._currentPromise = n, this._getSpeech(e, t).then((e => { if (!n.play.pending) return; if (this._currentPromise !== n) return void n.play.cancel(); const t = () => { this._currentSpeech = null, this._currentPromise = null }; this._currentSpeech && this._currentSpeech.playing && ("play" === i || "resume" === i && this._currentSpeech.audio !== e.audio) && this._currentSpeech.cancel(), this._setCurrentSpeech(e), n.speech = e[i](this._host.now, t, t, t), n.speech.then((() => { n.speech.resolved ? n.play.resolve() : n.play.cancel() })).catch((e => { n.play.reject(e) })) })).catch((t => { t = `Cannot ${i} speech ${e} on host ${this.host.id}. ${t}`, n.play.reject(t) })), n.play } play(e, t) { return this._startSpeech(e, t, "play") } pause() { this._currentSpeech && this._currentSpeech.playing ? this._currentSpeech.pause(this._host.now) : console.warn(`Cannot pause speech on host ${this.host.id}. No speech is currently playing`) } resume(e, t) { return this._startSpeech(e, t, "resume") } stop() { this._currentSpeech && this._currentSpeech.playing ? (this._currentSpeech.stop(), this._currentSpeech = null) : console.warn(`Cannot stop speech on host ${this.host.id}. No speech is currently playing.`) } discard() { this._currentSpeech && this._currentSpeech.playing && this._currentSpeech.stop(), delete this._speechCache, super.discard() } getEngineUserAgentString() { return "UnknownEngine" } } Object.defineProperties(AbstractTextToSpeechFeature, { AWS_VERSION: { get: () => fe }, POLLY_MIN_NEURAL_VERSION: { value: "2.503", writable: !1 }, POLLY_DEFAULTS: { value: { Engine: "standard", LexiconNames: [], OutputFormat: "mp3", SampleRate: "22050", Text: "", TextType: "ssml", VoiceId: "Amy", LanguageCode: "en-GB", LanguageName: "British English" }, writable: !1 }, POLLY_VOICES: { value: [], writable: !1 }, POLLY_LANGUAGES: { value: {}, writable: !1 }, POLLY_LANGUAGE_CODES: { value: {}, writable: !1 }, _isReady: { value: !1, writable: !0 }, EVENTS: { value: { ...Object.getPrototypeOf(AbstractTextToSpeechFeature).EVENTS, ready: "onReadyEvent", play: "onPlayEvent", pause: "onPauseEvent", resume: "onResumeEvent", interrupt: "onInterruptEvent", stop: "onStopEvent", sentence: "onSentenceEvent", word: "onWordEvent", viseme: "onVisemeEvent", ssml: "onSsmlEvent" } }, SERVICES: { value: { ...Object.getPrototypeOf(AbstractTextToSpeechFeature).SERVICES, polly: void 0, presigner: void 0 } } }); const ve = AbstractTextToSpeechFeature; const Ee = class TextToSpeechFeature extends ve{ constructor(...e) { super(...e), this._enabled = !1, this._setAudioContext(), this._observeAudioContext() } _setAudioContext() { this._audioContext = new AudioContext } _observeAudioContext() { this._audioContext && (this._audioContext.onstatechange = () => { "running" === this._audioContext.state ? this._enabled = !0 : (this._enabled = !1, console.warn('The audio context is not running. Speech will not be able to be played until it is resumed. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.')) }, this._audioContext.onstatechange()) } _synthesizeAudio(e) { return super._synthesizeAudio(e).then((e => { const { url: t } = e, i = new Audio(t); return i.loop = this.loop, i.crossOrigin = "anonymous", i.preload = "auto", e.audio = i, new Promise((t => { i.addEventListener("canplaythrough", (() => { t(e) })), document.body.appendChild(i), i.load() })) })) } _createSpeech(e, t, i) { return new re(this, e, t, i) } get enabled() { return this._enabled } resumeAudio() { return new s(((e, t) => { this._audioContext.resume().then((() => { this._enabled = !0, e() })).catch((e => { this._enabled = !1, t(e) })) })) } _startSpeech(e, t, i = "play") { const n = { play: new s(void 0, (() => { n.speech.cancel() }), (() => { n.speech.cancel() }), (() => { n.speech.cancel() })), speech: new s }; return this._currentPromise = n, this.resumeAudio().then((() => { n.play.pending && (this._currentPromise === n ? this._enabled ? super._startSpeech(e, t, i) : n.reject(new Error(`Cannot ${i} speech on host ${this._host.id}. The audio context is not running. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.`)) : n.play.cancel()) })), n.play } play(e, t) { return this._startSpeech(e, t, "play") } resume(e, t) { return this._startSpeech(e, t, "resume") } installApi() { const e = super.installApi(); return Object.defineProperties(e, { enabled: { get: () => this._enabled } }), e } }; const Ae = class LexUtils{ static downsampleAudio(e, t, i) { if (!e || !e.length) return; if (t === i) return e; if (t < i) throw Error(`Input Sample rate ${t} is less than target sample rate ${i}.`); const s = e.length, n = t / i, a = Math.round(s / n), r = new Float32Array(a); let o = 0, h = 0; for (; o < a;){ const t = Math.round((o + 1) * n); let i = 0, a = 0; for (let n = h; n < t && n < s; n++)i += e[n], a++; r[o] = i / a, o++, h = t } return r } static encodeWAV(e, t) { function i(e, t, i) { for (let s = 0; s < i.length; s++)e.setUint8(t + s, i.charCodeAt(s)) } if (!e) return; const s = new ArrayBuffer(44 + 2 * e.length), n = new DataView(s); return i(n, 0, "RIFF"), n.setUint32(4, 32 + 2 * e.length, !0), i(n, 8, "WAVE"), i(n, 12, "fmt "), n.setUint32(16, 16, !0), n.setUint16(20, 1, !0), n.setUint16(22, 1, !0), n.setUint32(24, t, !0), n.setUint32(28, 2 * t, !0), n.setUint16(32, 2, !0), n.setUint16(34, 16, !0), i(n, 36, "data"), n.setUint32(40, 2 * e.length, !0), function (e, t, i) { for (let s = 0; s < i.length; s++, t += 2){ const n = Math.max(-1, Math.min(1, i[s])); e.setInt16(t, n < 0 ? 32768 * n : 32767 * n, !0) } }(n, 44, e), n } }; class LexFeature extends h{ constructor(e, t = { botName: void 0, botAlias: void 0, userId: void 0 }) { if (super(), !e) throw Error("Cannot initialize Lex feature. LexRuntime must be defined"); e.config && (e.config.customUserAgent = n.addCoreUserAgentComponent(e.config.customUserAgent), e.config.customUserAgent = n.addStringOnlyOnce(e.config.customUserAgent, this.getEngineUserAgentString())), this._lexRuntime = e, this._botName = t.botName, this._botAlias = t.botAlias, this._userId = t.userId ? t.userId : n.createId(), this._micReady = !1, this._recording = !1, this._recLength = 0, this._recBuffer = [], this._setupAudioContext() } _setupAudioContext() { this._audioContext = new AudioContext } _processWithAudio(e, t, i = {}) { const s = this._prepareAudio(e, t); return this._process("audio/x-l16; rate=16000", s, i) } processWithText(e, t = {}) { return this._process("text/plain; charset=utf-8", e, t) } _process(e, t, i) { const s = this._validateConfig(i), n = { botName: s.botName, botAlias: s.botAlias, contentType: e, inputStream: t, userId: s.userId }; return new Promise(((e, t) => { this._lexRuntime.postContent(n, ((i, s) => i ? t(i) : e(s))) })).then((e => (this.emit(this.constructor.EVENTS.lexResponseReady, e), e))).catch((e => { const t = `Error happened during voice recording: ${e}. Please check whether your speech is more than 15s.`; throw console.error(t), new Error(t) })) } _validateConfig(e) { const t = {}; if (t.botName = e.botName ? e.botName : this._botName, t.botAlias = e.botAlias ? e.botAlias : this._botAlias, t.userId = e.userId ? e.userId : this._userId, !t.botName || !t.botAlias || !t.userId) throw new Error("Cannot process lex request. All arguments must be defined."); return t } _prepareAudio(e, t) { const i = Ae.downsampleAudio(e, t, this.constructor.LEX_DEFAULTS.SampleRate), s = Ae.encodeWAV(i, this.constructor.LEX_DEFAULTS.SampleRate); return new Blob([s], { type: "application/octet-stream" }) } async enableMicInput() { const e = await navigator.mediaDevices.getUserMedia({ audio: !0, video: !1 }), t = this._audioContext.createMediaStreamSource(e), i = this._audioContext.createScriptProcessor(4096, 1, 1); i.onaudioprocess = e => { if (!this._recording) return; const t = e.inputBuffer.getChannelData(0); this._recBuffer.push(new Float32Array(t)), this._recLength += t.length }, t.connect(i), i.connect(this._audioContext.destination), this.emit(this.constructor.EVENTS.micReady), this._micReady = !0 } beginVoiceRecording() { this._micReady && ("suspended" !== this._audioContext.state && "interrupted" !== this._audioContext.state || this._audioContext.resume(), this._recLength = 0, this._recBuffer = [], this._recording = !0, this.emit(this.constructor.EVENTS.recordBegin)) } endVoiceRecording() { if (!this._recording) return Promise.resolve(); this._recording = !1; const e = new Float32Array(this._recLength); let t = 0; for (let i = 0; i < this._recBuffer.length; i++)e.set(this._recBuffer[i], t), t += this._recBuffer[i].length; return this.emit(this.constructor.EVENTS.recordEnd), this._processWithAudio(e, this._audioContext.sampleRate) } getEngineUserAgentString() { return "UnknownEngine" } } Object.defineProperties(LexFeature, { LEX_DEFAULTS: { value: { SampleRate: "16000" }, writable: !1 }, EVENTS: { value: { ...Object.getPrototypeOf(LexFeature).EVENTS, lexResponseReady: "lexResponseReady", micReady: "micReady", recordBegin: "recordBegin", recordEnd: "recordEnd" } } }); const Se = { LexFeature, LexUtils: Ae, AbstractTextToSpeechFeature: ve, TextToSpeechFeature: Ee, TextToSpeechUtils: ne, AbstractSpeech: ae, Speech: re }, { Easing: be, AnimationFeature: we, AnimationTypes: Te, AnimationLayer: Le, LayerBlendModes: xe, DefaultLayerBlendMode: Ne, SingleState: Fe, TransitionState: Me, FreeBlendState: Oe, QueueState: Ce, RandomAnimationState: ke, Blend1dState: Ie, Blend2dState: Pe, AnimationUtils: $e } = (n.getVersion(), se), { LexFeature: Ve, LexUtils: Re, AbstractTextToSpeechFeature: We, TextToSpeechFeature: je, TextToSpeechUtils: De, AbstractSpeech: Be, Speech: Ue } = Se } }, t = {}; function i(s) { var n = t[s]; if (void 0 !== n) return n.exports; var a = t[s] = { exports: {} }; return e[s](a, a.exports, i), a.exports } i.d = (e, t) => { for (var s in t) i.o(t, s) && !i.o(e, s) && Object.defineProperty(e, s, { enumerable: !0, get: t[s] }) }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }; var s = {}; return (() => { i.r(s), i.d(s, { AxisMap: () => e.AxisMap, DefaultGestureWords: () => e.DefaultGestureWords, DefaultVisemeMap: () => e.DefaultVisemeMap, Deferred: () => e.Deferred, GestureFeature: () => e.GestureFeature, HostObject: () => a, LipsyncFeature: () => e.LipsyncFeature, MathUtils: () => e.MathUtils, Messenger: () => e.Messenger, PointOfInterestFeature: () => t, Utils: () => e.Utils, anim: () => d, aws: () => c, env: () => n }); var e = i(937); class PointOfInterestFeature extends e.PointOfInterestFeature{ static _getWorldPosition(e) { return e.updateWorldMatrix(!0, !1), e.matrixWorld.elements.slice(12, 15) } static _getWorldMatrix(e) { return e.updateWorldMatrix(!0, !1), [...e.matrixWorld.elements] } _validateTransformObject(e) { return e instanceof THREE.Object3D } setTargetByName(e) { super.setTargetByName(e), e && (this.target = this._scene.getObjectByName(e)) } setTargetById(e) { super.setTargetByName(e), e && (this.target = this._scene.getObjectById(e)) } } const t = PointOfInterestFeature, n = "three"; class HostObject extends e.HostObject{ constructor(e = {}) { super(e), this._clock = e.clock, this._clock && (Object.defineProperty(this, "now", { get: () => 1e3 * this._clock.getElapsedTime() }), this._lastUpdate = this.now), this._dispatcher = this } _createEvent(e, t) { return { detail: t, type: e } } } Object.getOwnPropertyNames(THREE.EventDispatcher.prototype).filter((e => "constructor" !== e)).forEach((t => { e.Messenger.prototype[t] = THREE.EventDispatcher.prototype[t] })); const a = HostObject; class Speech extends e.Speech{ constructor(e, t, i = [], s) { super(e, t, i, s), this._threeAudio = s.threeAudio } get audio() { return this._threeAudio } _pauseAudio() { this._audio.pause() } play(e, t, i, s) { return this._threeAudio.disconnect(), this._threeAudio.connect(), super.play(e, t, i, s) } } const r = Speech; class TextToSpeechFeature extends e.TextToSpeechFeature{ constructor(e, t = { voice: void 0, engine: void 0, language: void 0, audioFormat: "mp3", sampleRate: void 0, listener: void 0, attachTo: void 0 }) { super(e, t), this._listener = t.listener, this._attachTo = t.attachTo || e.owner, this._setAudioContext(), this._observeAudioContext() } _setAudioContext() { this._listener && (this._audioContext = this._listener.context) } _synthesizeAudio(e) { return super._synthesizeAudio(e).then((e => (void 0 === this._attachTo || this._isGlobal ? e.threeAudio = new THREE.Audio(this._listener) : (e.threeAudio = new THREE.PositionalAudio(this._listener), this._attachTo.add(e.threeAudio)), e.threeAudio.setMediaElementSource(e.audio), e))) } _createSpeech(e, t, i) { return new r(this, e, t, i) } getEngineUserAgentString() { return `Three.js-${THREE.REVISION}` } } const o = TextToSpeechFeature; class LexFeature extends e.LexFeature{ _setupAudioContext() { this._audioContext = THREE.AudioContext.getContext() } } const h = LexFeature, c = { TextToSpeechFeature: o, Speech: r, TextToSpeechUtils: e.TextToSpeechUtils, LexFeature: h, LexUtils: e.LexUtils }, l = { Override: THREE.NormalAnimationBlendMode, Additive: THREE.AdditiveAnimationBlendMode }; class SingleState extends e.SingleState{ constructor(e = {}, t) { super(e), this._onFinishedEvent = ({ type: e, action: t }) => { "finished" === e && t === this.threeAction && (this._promises.play.resolve(), this.weightPending || this.timeScalePending || (this._paused = !0)) }, this._threeAction = t, this._threeAction.clampWhenFinished = !0, this._threeAction.enabled = !1, this._threeAction.loop = 1 === this._loopCount ? THREE.LoopOnce : THREE.LoopRepeat, this._threeAction.paused = this._paused, this._threeAction.repetitions = this._loopCount, this._threeAction.timeScale = this._timeScale, this._threeAction.weight = this._internalWeight, this._threeAction.blendMode = l[this._blendMode], this._threeAction.getMixer().addEventListener("finished", this._onFinishedEvent) } get threeAction() { return this._threeAction } get normalizedTime() { return this._threeAction.time && this._threeAction.getClip() && this._threeAction.getClip().duration ? this._threeAction.time / this._threeAction.getClip().duration : 0 } set normalizedTime(t) { t = e.MathUtils.clamp(t), this._threeAction.time = this._threeAction.getClip().duration * t } get weight() { return super.weight } set weight(e) { super.weight = e, this._threeAction.enabled = !0 } updateInternalWeight(e) { super.updateInternalWeight(e), this._threeAction.setEffectiveWeight(this._internalWeight) } get timeScale() { return super.timeScale } set timeScale(e) { super.timeScale = e, this._threeAction.timeScale = e } get loopCount() { return super.loopCount } set loopCount(e) { super.loopCount = e, this._threeAction.loop = 1 === e ? THREE.LoopOnce : THREE.LoopRepeat, this._threeAction.repetitions = e } play(e, t, i) { return this._threeAction.reset(), this._threeAction.play(), super.play(e, t, i) } pause() { return this._threeAction.paused = !0, this._threeAction.play(), super.pause() } resume(e, t, i) { return this._threeAction.paused = !1, this._threeAction.enabled = !0, this._threeAction.play(), super.resume(e, t, i) } cancel() { return this._threeAction.paused = !0, super.cancel() } stop() { return this._threeAction.reset(), this._threeAction.paused = !0, this._threeAction.play(), super.stop() } discard() { this._threeAction.enabled = !1, this._threeAction.getMixer().removeEventListener("finished", this._onFinishedEvent), super.discard() } } const u = SingleState; e.AnimationTypes.single = u; class AnimationFeature extends e.AnimationFeature{ constructor(e) { super(e), this._mixer = new THREE.AnimationMixer(e.owner) } _createSingleState(e) { let { clip: t } = e; this._mixer.existingAction(t) && (t = t.clone()); const i = this._mixer.clipAction(t); return new u(e, i) } get mixer() { return this._mixer } update(e) { super.update(e), this._paused || this._mixer.update(e / 1e3) } discard() { this._mixer.uncacheRoot(this._host.owner), super.discard() } } const d = { AnimationFeature, SingleState: u, AnimationLayer: e.AnimationLayer, TransitionState: e.TransitionState, FreeBlendState: e.FreeBlendState, QueueState: e.QueueState, RandomAnimationState: e.RandomAnimationState, Blend1dState: e.Blend1dState, Blend2dState: e.Blend2dState, AnimationUtils: e.AnimationUtils, Easing: e.Easing, LayerBlendModes: e.LayerBlendModes, DefaultLayerBlendMode: e.DefaultLayerBlendMode, AnimationTypes: e.AnimationTypes } })(), s })()));